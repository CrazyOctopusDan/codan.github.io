<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>gitflow 操作思考</title>
      <link href="/2021/03/04/gitflow%20%E6%93%8D%E4%BD%9C%E6%80%9D%E8%80%83/"/>
      <url>/2021/03/04/gitflow%20%E6%93%8D%E4%BD%9C%E6%80%9D%E8%80%83/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-Flow-的另一种思路"><a href="#Git-Flow-的另一种思路" class="headerlink" title="Git Flow 的另一种思路"></a>Git Flow 的另一种思路</h1><blockquote><p>Master 分支 下文简称（M)<br>Test 分支 下文简称 (T)<br>Feature 分支 下文简称（F）<br>Hotfix 分支 下文简称（H）<br>Merge Request 操作请求 下文简称（MR）</p></blockquote><p>高度精简为一句话：一切分支都从Master分支中拉出！</p><h2 id="迭代开始"><a href="#迭代开始" class="headerlink" title="迭代开始"></a>迭代开始</h2><p>暂定当前迭代为Vn，则上一个稳定迭代的版本为Vn-1。</p><p>首先从<code>M -&gt; T</code>，作为开发过程中的测试分支。</p><p>根据产品文档等需求划分工具提示，每一位同志按照自己手头的工作进行:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M -&gt; F1</span><br><span class="line">M -&gt; F2</span><br><span class="line">...</span><br><span class="line">M -&gt; Fn</span><br></pre></td></tr></table></figure><p>然后根据各自的时间安排进行开发</p><h2 id="迭代进行时"><a href="#迭代进行时" class="headerlink" title="迭代进行时"></a>迭代进行时</h2><p>流程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">M -&gt; F (F&#39; F&#39;&#39; ...) -&gt; T</span><br></pre></td></tr></table></figure><h3 id="正常迭代开发测试合并"><a href="#正常迭代开发测试合并" class="headerlink" title="正常迭代开发测试合并"></a>正常迭代开发测试合并</h3><p>同志张三正在进行自己的<code>F3</code>功能需求开发，那么他每天需要：</p><ol><li>是否为协同开发？是=&gt;2，否=&gt;3</li><li>拉取远程分支的代码到本地，处理同伴开发可能导致的冲突；</li><li>进行本地开发、测试；</li><li>下班前在本地暂存修改，做好commit记录提交到远程仓库；</li><li>在仓库中发起MR，指定对应的Code Review对象为assignee，如果该需求正在开发过程中，则需要点击<img src="https://img.imgdb.cn/item/60403915360785be541f82da.png" alt=""><br> 之后就会变成<img src="https://img.imgdb.cn/item/60403983360785be541fadba.png" alt=""><br> 提交之后可以方便Code Review的同志今天代码检查；<br> 如果已经开发完成确保可以合并，那么可以在MR中点击<code>Remove the WIP: prefix from the title...</code>，这样在代码检查完毕之后便可以合并到对应的<code>T</code>中了。</li></ol><h3 id="发生了conflict"><a href="#发生了conflict" class="headerlink" title="发生了conflict!"></a>发生了conflict!</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">M -&gt; F3 -&gt; T</span><br><span class="line"></span><br><span class="line">M -&gt; F4 -&gt; T </span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 此时F3和F4中都对 FileA 进行了修改 发生了冲突</span><br></pre></td></tr></table></figure><p>同志张三和同志李四在各自的<code>F</code>中都对同一个文件进行了修改，因此在合并到<code>T</code>时发生了冲突；</p><p>解决方案：</p><ol><li><p>发现产生冲突的同志，在完成Code Review后，将<code>T</code>拉到本地后，进行冲突解决，再提交<code>T</code>；（推荐）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">origin&#x2F;T -&gt; T</span><br><span class="line">F4 -&gt; T (fix conflict)</span><br><span class="line">T -&gt; origin&#x2F;T</span><br></pre></td></tr></table></figure></li><li><p>发现产生冲突的同志，在完成Code Review后，从<code>M -&gt; F(3+4)</code>，然后联合与自己产生冲突的同学把各自的<code>F</code>合并到<code>F(3+4)</code>中；（避免在最后每个人把各自的<code>F</code>合并到<code>M</code>的时候再解决一次冲突，但是有可能产生很多F（n+m），慎用）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">M -&gt; F(3+4)</span><br><span class="line">F3 -&gt; F(3+4)</span><br><span class="line">F4 -&gt; F(3+4)</span><br><span class="line">F(3+4) -&gt; origin&#x2F;F(3+4) -&gt; T</span><br></pre></td></tr></table></figure></li></ol><h3 id="迭代结束"><a href="#迭代结束" class="headerlink" title="迭代结束"></a>迭代结束</h3><p>现在迭代完成了，需要把所有的<code>F</code>分支合并到<code>M</code>上面进行发布上线操作；</p><h4 id="常规状态"><a href="#常规状态" class="headerlink" title="常规状态"></a>常规状态</h4><p>在确保<code>T</code>的测试充足情况下是可以直接合并到<code>M</code>的，而且这种时候几乎不会产生任何冲突，平滑合并上线。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 方案1 --&gt;</span><br><span class="line">T -&gt; M</span><br><span class="line">&#x2F;&#x2F; 等于</span><br><span class="line">&lt;!-- 方案2 --&gt;</span><br><span class="line">F1 -&gt; M</span><br><span class="line">F2 -&gt; M</span><br><span class="line">...</span><br><span class="line">Fn -&gt; M</span><br></pre></td></tr></table></figure><h4 id="突发情况"><a href="#突发情况" class="headerlink" title="突发情况"></a>突发情况</h4><blockquote><p>“由于xx功能考虑不周，本次迭代不上了”——产品经理<br>“我还想在XX功能上面增加亿点点东西……”——产品经理</p></blockquote><p>在某些情况下会出现<code>Fn</code>这个功能需求无法上线的情况，这个时候需要：</p><ol><li>各自合并:</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">F1 -&gt; M</span><br><span class="line">F2 -&gt; M</span><br><span class="line">...</span><br><span class="line">Fn-1 -&gt; M</span><br><span class="line">&#x2F;&#x2F; Fn 不合并</span><br><span class="line">&#x2F;&#x2F; 在master上面解决一下冲突，如果master受到保护，则需要看方案2</span><br></pre></td></tr></table></figure><ol><li>拉取一个新的<code>T2</code>，把除了不上线的需求都合入其中，进行回归测试后合入<code>M</code></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">M -&gt; T2</span><br><span class="line">F1 -&gt; T2</span><br><span class="line">F2 -&gt; T2</span><br><span class="line">...</span><br><span class="line">Fn-1 -&gt; T2</span><br><span class="line"></span><br><span class="line">T2 -&gt; M</span><br></pre></td></tr></table></figure><h3 id="发现历史bug"><a href="#发现历史bug" class="headerlink" title="发现历史bug"></a>发现历史bug</h3><p>历史bug为在 上线的版本中发现的功能上的缺陷，需要及时地进行修改；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">M -&gt; H -&gt; T &#x2F;&#x2F; 进行测试</span><br><span class="line"></span><br><span class="line">H -&gt; M &#x2F;&#x2F; 测试完成后可以快速上线</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> gitflow 共同协作 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React源码学习</title>
      <link href="/2020/06/11/React%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <url>/2020/06/11/React%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="React-dom-源码阅读"><a href="#React-dom-源码阅读" class="headerlink" title="React-dom 源码阅读"></a>React-dom 源码阅读</h1><h2 id="react-dom-render"><a href="#react-dom-render" class="headerlink" title="react-dom-render"></a>react-dom-render</h2><p>首先 =&gt; 创建<br>ReactDOM.render</p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>创建ReactRoot</li><li>创建FiberRoot和RootFiber</li><li>创建更新</li></ol><p>通过DOM <code>Renderer.createContainer</code> 创建了一个 <code>FiberRoot</code>；</p><p>接下来挂载到<code>container._reactRootContainer</code>上面；</p><p>然后最重要的是，调用 <code>DOMRenderer.unbatchedUpdates</code>（批量更新），修改了scheduler里面的一个全局变量；</p><p>返回了一个<code>root.render(children, callback)</code> =&gt; 其实这里的操作最重要是调用了<code>DOMRenderer.updateContainer(children, root, null, work._onCommit)</code> =&gt; 关键函数<code>updateContainerAtExpirationTime</code> 这里有个关键参数是 expirationTime （有效期限？失效时间？）=&gt; <code>scheduleRootUpdate</code> 中使用 <code>createUpdate</code>标记更新的位置，使用<code>enqueueUpdate</code>批量更新，使用<code>scheduleWork</code>调度工作（因为react16有任务优先级）</p><h3 id="关键性函数"><a href="#关键性函数" class="headerlink" title="关键性函数"></a>关键性函数</h3><p>首先在ReactDOM.js中找到 ReactDOM 对象 中的 render<br>在 render 的方法中仔细分析 <code>legacyRenderSubtreeIntoContainer(null, element, container, false, callback)</code></p><p>第一个参数是 parentComponent ，接着往下是找到root，<br>然而在新建的时候一定不会有reactRootContainer，所以创建的时候就只需要关注<code>!root</code></p><p>第四个参数是false，跟 hydrate 相关，这个在服务端渲染中有用，告诉react是否可以复用别的节点。</p><h3 id="FiberRoot"><a href="#FiberRoot" class="headerlink" title="FiberRoot"></a>FiberRoot</h3><ul><li>整个应用的起点</li><li>包含应用挂载的目标节点</li><li>记录整个应用更新过程的各种信息</li></ul><p><a href="https://react.jokcy.me/book/api/react-structure.html">数据结构</a></p><h3 id="Fiber"><a href="#Fiber" class="headerlink" title="Fiber"></a>Fiber</h3><ul><li>每一个ReactElement都会对应一个Fiber对象</li><li>记录节点的各种状态</li><li>串联整个应用形成树结构</li></ul><p><a href="https://react.jokcy.me/book/api/react-structure.html">数据结构</a></p><p>串联整个应用形成树结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    return,   &#x2F;&#x2F; 返回父节点</span><br><span class="line">    child,    &#x2F;&#x2F; 第一个子节点</span><br><span class="line">    sibling   &#x2F;&#x2F; 第一个子节点的兄弟节点</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只存一个child（第一个子节点），其他的子节点都是第一个child的sibling</p><p>等等等</p><h3 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h3><p>用于记录组件状态的改变<br>存放于UpdateQueue中<br>多个Update可以同时存在</p><p><a href="https://react.jokcy.me/book/api/react-structure.html">数据结构</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>G6使用指南</title>
      <link href="/2020/06/09/G6%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/"/>
      <url>/2020/06/09/G6%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="G6-使用指南"><a href="#G6-使用指南" class="headerlink" title="G6 使用指南"></a>G6 使用指南</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><pre><code>在吾来产品中有任务机器人的画布功能，我们在设计之初调研了众多库，最后挑选了一款将canvas和HTML DOM结合地不错的JSPlumb库，的的确确也很大程度上完成了功能的开发，在效果上也具有不错的体现，然而在后期，产品团队和设计团队想要对这个画布功能进行修改的时候便遭遇了极大困难，所以说，JSPlumb是一款起点和上限都不高的库。   于是静极思变，我们看见了现在新的库G6，作为阿里团队开发维护的库，我们决定去尝试一下。</code></pre><h2 id="G6"><a href="#G6" class="headerlink" title="G6"></a>G6</h2><pre><code>G6 是一个简单、易用、完备、开源的图可视化引擎，它在高定制能力的基础上，提供了一系列设计优雅、便于使用的图可视化解决方案。能帮助开发者搭建属于自己的图可视化、图分析、或图编辑器应用。</code></pre><h2 id="Graphin"><a href="#Graphin" class="headerlink" title="Graphin"></a>Graphin</h2><pre><code>Graphin 取名意为 Graph Insight（图的分析洞察），是一个基于 G6 封装的 React 组件库。简单，高效，开箱即用。Graphin由于UIbot-Observer平台的高速迭代带来了极大的压力，我便把目光放到了这个库上面，的的确确Graphin为快速开发带来了极大的便利，但是也带来不少的问题。</code></pre><h2 id="搭建"><a href="#搭建" class="headerlink" title="搭建"></a>搭建</h2><pre><code>搭建一个graphin图表基本上需要：</code></pre><p>1.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @antv/graphin --save</span><br></pre></td></tr></table></figure><p>2.</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Graphin data /&gt;</span><br></pre></td></tr></table></figure><pre><code>的确必要元素就可以这么少，当然，这么点东西肯定不能满足业务需求，大致看一看PRD中和设计提供的原型图，要满足需求需要确定整体布局、改变节点样式、改变边的样式、提供放大缩小的功能、提供全屏的功能……</code></pre><h3 id="确定整体布局"><a href="#确定整体布局" class="headerlink" title="确定整体布局"></a>确定整体布局</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;Graphin</span><br><span class="line">    data=&#123;listData&#125;</span><br><span class="line">    layout=&#123;LayoutOpt&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> LayoutOpt = &#123;</span><br><span class="line">    name: <span class="string">&#x27;dagre&#x27;</span>,</span><br><span class="line">    options: &#123;</span><br><span class="line">     rankdir: <span class="string">&#x27;TB&#x27;</span>,</span><br><span class="line">     align: <span class="string">&#x27;UL&#x27;</span>,</span><br><span class="line">     nodesep: <span class="number">200</span>,</span><br><span class="line">     ranksep: <span class="number">5</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>整体布局名称为 dagre ，是一种层次布局，</p></li><li><p>rankdir是布局的方向 Top =&gt; Bottom</p></li><li><p>align是对齐方式，枚举值，Up Left</p></li><li><p>ranksep和nodesep都是间隔值</p></li></ul><h3 id="修改节点样式"><a href="#修改节点样式" class="headerlink" title="修改节点样式"></a>修改节点样式</h3><pre><code>扩展API  `&lt;Graphin/&gt;` 组件 props.extend 配置。用于配置 Graphin 布局/NodeShape/Marker 的扩展。想要实现一个自己满意的节点，那就不能使用Graphin提供的默认的节点样式了，需要自己手动编写一个G6对象实例，里面包括节点的名称、节点的配置等等，talk is cheap，show me the code</code></pre><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">&lt;Graphin</span><br><span class="line">     data=&#123;listData&#125;</span><br><span class="line">     layout=&#123;LayoutOpt&#125;</span><br><span class="line"></span><br><span class="line">         extend=&#123;&#123;</span><br><span class="line">          nodeShape: extendNodeShape,</span><br><span class="line">     &#125;&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  基础样式配置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> defaultStyles = &#123;</span><br><span class="line">     <span class="comment">/** 容器 */</span></span><br><span class="line">     containerWidth: <span class="number">180</span>,</span><br><span class="line">     containerHeight: <span class="number">40</span>,</span><br><span class="line">     containerStroke: <span class="string">&#x27;#687c8a&#x27;</span>, <span class="comment">// 边框色</span></span><br><span class="line">     containerFill: <span class="string">&#x27;#687c8a&#x27;</span>, <span class="comment">// 背景色</span></span><br><span class="line">     <span class="comment">/** 文本 */</span></span><br><span class="line">     fontColor: <span class="string">&#x27;#FFF&#x27;</span>,</span><br><span class="line">     fontColorDark: <span class="string">&#x27;#425b6d&#x27;</span>,</span><br><span class="line">     fontSize: <span class="number">14</span>,</span><br><span class="line">     <span class="comment">/** 深色 */</span></span><br><span class="line">     dark: <span class="string">&#x27;#425b6d&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Graphin Node 自定义样式</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="variable">graphin</span></span></span></span><br><span class="line"><span class="comment">* <span class="doctag">@param <span class="variable">props</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> extendNodeShape = <span class="function">(<span class="params">graphin: any, props: any</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">return</span> [</span><br><span class="line">&#123;</span><br><span class="line">name: <span class="string">&#x27;APPS&#x27;</span>,</span><br><span class="line">render: <span class="function">(<span class="params">node: &#123; style: any; data: any &#125;</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">const</span> style = &#123;</span><br><span class="line">     ...defaultStyles,</span><br><span class="line">     ...node.style,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">     shape: <span class="string">&#x27;RectNode&#x27;</span>,</span><br><span class="line">     shapeComponents: [</span><br><span class="line">     &#123;</span><br><span class="line">          shape: <span class="string">&#x27;rect&#x27;</span>,</span><br><span class="line">          attrs: &#123;</span><br><span class="line">               id: <span class="string">&#x27;rect-container&#x27;</span>,</span><br><span class="line">               x: <span class="number">0</span>,</span><br><span class="line">               y: <span class="number">0</span>,</span><br><span class="line">               width: style.containerWidth,</span><br><span class="line">               height: style.containerHeight,</span><br><span class="line">               fill: style.containerFill,</span><br><span class="line">               stroke: style.containerStroke,</span><br><span class="line">               cursor: <span class="string">&#x27;pointer&#x27;</span>,</span><br><span class="line">               lineWidth: <span class="number">2</span>,</span><br><span class="line">               radius: [<span class="number">4</span>],</span><br><span class="line">          &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">          shape: <span class="string">&#x27;circle&#x27;</span>,</span><br><span class="line">          attrs: &#123;</span><br><span class="line">              id: <span class="string">&#x27;badge&#x27;</span>,</span><br><span class="line">               x: style.containerWidth,</span><br><span class="line">               y: <span class="number">0</span>,</span><br><span class="line">               r: style.badgeSize,</span><br><span class="line">               fill: style.badgeFill,</span><br><span class="line">               cursor: <span class="string">&#x27;pointer&#x27;</span>,</span><br><span class="line">               lineWidth: <span class="number">1</span>,</span><br><span class="line">             &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">          shape: <span class="string">&#x27;text&#x27;</span>, <span class="comment">// 这是右上角的badge 徽记</span></span><br><span class="line">          attrs: &#123;</span><br><span class="line">                id: <span class="string">&#x27;badge-text&#x27;</span>,</span><br><span class="line">                x: style.containerWidth / <span class="number">2</span>,</span><br><span class="line">                y: -<span class="number">4</span>,</span><br><span class="line">                fontSize: <span class="number">10</span>,</span><br><span class="line">                cursor: <span class="string">&#x27;pointer&#x27;</span>,</span><br><span class="line">                fill: <span class="string">&#x27;#fff&#x27;</span>,</span><br><span class="line">                textAlign: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                textBaseline: <span class="string">&#x27;top&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">          shape: <span class="string">&#x27;Marker&#x27;</span>,</span><br><span class="line">          attrs: &#123;</span><br><span class="line">                id: <span class="string">&#x27;node-icon&#x27;</span>,</span><br><span class="line">                symbol: node.data.type,</span><br><span class="line">                x: style.containerWidth / <span class="number">2</span>,</span><br><span class="line">                y: style.containerWidth / <span class="number">2</span>,</span><br><span class="line">                r: style.iconSize,</span><br><span class="line">                fill: style.iconFill,</span><br><span class="line">          &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">     &#123;</span><br><span class="line">          shape: <span class="string">&#x27;text&#x27;</span>,</span><br><span class="line">          attrs: &#123;</span><br><span class="line">                id: <span class="string">&#x27;text-desc&#x27;</span>,</span><br><span class="line">                text: node.data.label,</span><br><span class="line">                x: style.containerWidth / <span class="number">2</span>,</span><br><span class="line">                y: style.containerHeight / <span class="number">2</span>,</span><br><span class="line">                cursor: <span class="string">&#x27;pointer&#x27;</span>,</span><br><span class="line">                fontSize: style.fontSize,</span><br><span class="line">                fill: style.fontColor,</span><br><span class="line">                fontWeight: <span class="string">&#x27;bolder&#x27;</span>,</span><br><span class="line">                fontFamily: <span class="string">&#x27;Courier New&#x27;</span>,</span><br><span class="line">                textAlign: <span class="string">&#x27;center&#x27;</span>,</span><br><span class="line">                textBaseline: <span class="string">&#x27;middle&#x27;</span>,</span><br><span class="line">          &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">],</span><br><span class="line">state: &#123;</span><br><span class="line">        selected: &#123;</span><br><span class="line">                <span class="string">&#x27;rect-container&#x27;</span>: &#123;</span><br><span class="line">                stroke: style.containerStroke,</span><br><span class="line">                fill: style.containerStroke,</span><br><span class="line">                animate: &#123;</span><br><span class="line">                     attrs: &#123;</span><br><span class="line">                              lineWidth: <span class="number">6</span>,</span><br><span class="line">                              shadowOffsetX: <span class="number">0</span>,</span><br><span class="line">                              shadowOffsetY: <span class="number">0</span>,</span><br><span class="line">                              shadowBlur: <span class="number">2</span>,</span><br><span class="line">                              shadowColor: <span class="string">&#x27;#fff&#x27;</span>,</span><br><span class="line">                              repeat: <span class="literal">false</span>, <span class="comment">// 循环</span></span><br><span class="line">                     &#125;,</span><br><span class="line">                     duration: <span class="number">200</span>,</span><br><span class="line">                     easing: <span class="string">&#x27;easeCubic&#x27;</span>,</span><br><span class="line">                     callback: <span class="literal">null</span>,</span><br><span class="line">                     delay: <span class="number">0</span>,</span><br><span class="line">                 &#125;,</span><br><span class="line">                    &#125;,</span><br><span class="line">                <span class="string">&#x27;node-icon&#x27;</span>: &#123;</span><br><span class="line">                 fill: <span class="string">&#x27;#fff&#x27;</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">                badge: &#123;</span><br><span class="line">                 lineWidth: <span class="number">6</span>,</span><br><span class="line">                &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上代码中，我注册了一个名为“APPS”的节点，</p><ul><li><p>它主体是一个矩形’rect’，起点位置[0, 0]，Fill代表的是填充的背景色，Stroke代表的是边框的颜色，lineWidth代表是他的粗细；</p></li><li><p>右上角会有圆形的徽标’cicle’；</p></li><li><p>徽标中会有text；</p></li><li><p>在主体中也有text；</p></li><li><p>在选中（selected）的时候会有一个动画出现——整个节点的边框会变粗。</p></li></ul><blockquote><p>你想用什么节点就自己接入吧。</p></blockquote><h3 id="改变边的样式"><a href="#改变边的样式" class="headerlink" title="改变边的样式"></a>改变边的样式</h3><p>这个就需要写在data当中了</p><hr><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在data中的设置</span></span><br><span class="line">style: EdgeStyle,</span><br><span class="line">labelCfg: FontStyle,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 边的样式</span></span><br><span class="line"><span class="keyword">const</span> EdgeStyle = &#123;</span><br><span class="line">    lineWidth: <span class="number">2</span>,</span><br><span class="line">    stroke: <span class="string">&#x27;#b3bdc5&#x27;</span>,</span><br><span class="line">    endArrow: <span class="literal">true</span>,</span><br><span class="line">    strokeOpacity: <span class="number">0.7</span>,</span><br><span class="line">    shadowColor: <span class="string">&#x27;#b3bdc5&#x27;</span>,</span><br><span class="line">    shadowBlur: <span class="number">1</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字体样式</span></span><br><span class="line"><span class="keyword">const</span> FontStyle = &#123;</span><br><span class="line">    style: &#123;</span><br><span class="line">    fill: <span class="string">&#x27;#425b6d&#x27;</span>,</span><br><span class="line">    lineWidth: <span class="number">4</span>,</span><br><span class="line">    opacity: <span class="number">0.7</span>,</span><br><span class="line">    fontSize: <span class="number">14</span>,</span><br><span class="line">    fontWeight: <span class="number">600</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>都非常容易理解的参数就不一一介绍了</p><h3 id="增加放大缩小全屏功能"><a href="#增加放大缩小全屏功能" class="headerlink" title="增加放大缩小全屏功能"></a>增加放大缩小全屏功能</h3><p>这个功能听起来高大上或许非常难以实现，但是其实G6都暴露出来了api，并且Graphin都已经做好了封装，只需要：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; Toolbar &#125; <span class="keyword">from</span> <span class="string">&#x27;@antv/graphin-components&#x27;</span></span><br><span class="line"></span><br><span class="line">&lt;Graphin&gt;</span><br><span class="line">    &lt;Toolbar /&gt;</span><br><span class="line">&lt;/Graphin&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>so ez</p>]]></content>
      
      
      
        <tags>
            
            <tag> UMI3 G6 Graphin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用UMI3搭建项目心得</title>
      <link href="/2020/06/01/%E4%BD%BF%E7%94%A8UMI3%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%96%B0%E7%9A%84/"/>
      <url>/2020/06/01/%E4%BD%BF%E7%94%A8UMI3%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E6%96%B0%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<blockquote><p> 写这一篇之前感谢子杰同学的付出，给我们搭建了一套基于umi3的框架，内置了启动配置等等耗时的基础操作，达到了快速启动项目的目的。</p></blockquote><hr><p>但是在使用中仍然需要注意几点，听我细细道来。</p><h2 id="UMI3"><a href="#UMI3" class="headerlink" title="UMI3"></a>UMI3</h2><h3 id="基础结构"><a href="#基础结构" class="headerlink" title="基础结构"></a>基础结构</h3><p>这个是给小白说的，虽然umi3的写法超高度类似于reactjs的写法，但是不代表你就可以不去阅读umi3的文档了。</p><p>当然阅读了文档也不代表你就全部领悟了（可能因为作者默认你是老的开发者，所以有部分change他会说是从umi2中变换而来的，想了解还是得看一眼早期文档）</p><p>有意思的是他的项目目录结构：</p><p><code>src/layouts</code>：作为页面的基础布局，可以有多个<br><code>src/pages</code>: 作为各个路由对应的页面<br>这俩是默认的↑</p><p><code>src/components</code>: 组件<br><code>src/grpc</code>: 如果你接口的接入方式是grpc-web，注意这里面的目录层级结构需要和编译出来的proto文件所在的目录层级一致<br><code>src/utils....</code><br>这些是约定俗成的↑</p><h3 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h3><p>几乎全部在<code>.umirc.ts</code>文件内</p><p>不同于umi2x版本的层级配置，Umi3的配置全部拉平，第一次写就会有点懵逼，但是胆子大一点多尝试尝试就会好受的。</p><h3 id="开始踩坑"><a href="#开始踩坑" class="headerlink" title="开始踩坑"></a>开始踩坑</h3><h4 id="小坑1-routes-配置"><a href="#小坑1-routes-配置" class="headerlink" title="小坑1 routes 配置"></a>小坑1 routes 配置</h4><p>routes 配置中要把路由结构写清晰（虽然他说可以默认按照文件目录结构生成，但是个人尝试了似乎并不好使）</p><p>什么意思呢？</p><p>比方说你拥有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">pages&#x2F;login</span><br><span class="line"></span><br><span class="line">pages&#x2F;center1</span><br><span class="line"></span><br><span class="line">pages&#x2F;center2</span><br><span class="line"></span><br><span class="line">pages&#x2F;center2&#x2F;:hash</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>理论上通过路由，Umi3会帮你匹配到你目录结构下面的各个文件，然而，你的需求可能远不止此：</p><p>login页面的布局和其他页面并不相同<br>center2的详情页的和center2的页面路由很相似<br>…<br>这个时候如果你不在配置中写得明明白白的，我保证一个星期后你自己都不认得这个项目了。</p><p>正确示范↓</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/login&#x27;</span>,</span><br><span class="line">        title: <span class="string">&#x27;登录&#x27;</span>,</span><br><span class="line">        component: <span class="string">&#x27;@/pages/login&#x27;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        component: <span class="string">&#x27;@/layouts/index&#x27;</span>,</span><br><span class="line">        routes: [</span><br><span class="line">            &#123;</span><br><span class="line">                path: <span class="string">&#x27;/center1&#x27;</span>,</span><br><span class="line">                title: <span class="string">&#x27;xx中心&#x27;</span>,</span><br><span class="line">                component: <span class="string">&#x27;@/pages/center1&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                path: <span class="string">&#x27;/center2&#x27;</span>,</span><br><span class="line">                title: <span class="string">&#x27;yy中心&#x27;</span>,</span><br><span class="line">                component: <span class="string">&#x27;@/pages/center2&#x27;</span>,</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                exact: <span class="literal">true</span>,</span><br><span class="line">                path: <span class="string">&#x27;/center2/:hash&#x27;</span>,</span><br><span class="line">                title: <span class="string">&#x27;yy详情&#x27;</span>,</span><br><span class="line">                component: <span class="string">&#x27;@/pages/centers/[hash]&#x27;</span>,</span><br><span class="line">             &#125;,</span><br><span class="line">         ],</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里有个坑存在：文档中默认 <code>exact: false</code>，但是如果你没事儿就千万不要自己写在route的配置中，写进去立马让这段匹配不好使！</p><p>其他的怎么定义路由就不细说了，文档里面全都有。</p><h4 id="小坑2-dva-类react-redux"><a href="#小坑2-dva-类react-redux" class="headerlink" title="小坑2 dva 类react redux"></a>小坑2 dva 类react redux</h4><p>这个只需要在配置中写上即可，文档中一笔带过，不注意的人还发现不了嘿，不用自己再装一遍react-redux！</p><h4 id="小坑3-Umi3自带了antd4"><a href="#小坑3-Umi3自带了antd4" class="headerlink" title="小坑3 Umi3自带了antd4"></a>小坑3 Umi3自带了antd4</h4><p>这导致什么问题？（写作时间2020/5.20）我们现在的组件库仍然是antd3x</p><p>理论上我们开发项目要用到组件库，那就简单安装一下下laiye-antd即可，我们的laiye-antd会自己自觉引用项目中依赖的antd。</p><p>now注意！坑就在此，不知道发生了什么情况，在项目编译的时候会检查laiye-antd。由于 antd3x =&gt; antd4x中删除了moment组件，修改了select组件的样式，独立了icon等，导致了编译时会报错moment找不到！</p><p>百思不得其解，涉及到npm包和npm包里的npm包，情况相当不明朗，不过还是有解决方案的：</p><p>在umirc.ts文件中增加一行配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">extraBabelPlugins: [</span><br><span class="line">    [<span class="string">&#x27;import&#x27;</span>, &#123;</span><br><span class="line">        libraryName: <span class="string">&#x27;laiye-antd&#x27;</span>,</span><br><span class="line">        style: <span class="string">&#x27;css&#x27;</span></span><br><span class="line">    &#125;, <span class="string">&#x27;laiye-antd&#x27;</span>],</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>声明，我们要按需加载laiye-antd，用什么加载什么，这样编译的时候就会放过moment组件了。</p><p>至于select组件使用时候丢失样式什么的，直接</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; select &#125; <span class="keyword">from</span> <span class="string">&#x27;laiye-antd&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; select &#125; <span class="keyword">from</span> <span class="string">&#x27;antd&#x27;</span></span><br></pre></td></tr></table></figure><p>就行了</p><h2 id="项目部署"><a href="#项目部署" class="headerlink" title="项目部署"></a>项目部署</h2><h3 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h3><p>项目部署需要几个关键文件（夹）</p><p>/docker/baseimg.Dockerfile<br>/docker/Dockerfile<br>/docker/start.sh<br>/Jenkinsfile (由运维同学提供)<br>/pm2.json<br>在后端gitlab仓库中的配置模板项目（config-templates）中增加线上配置</p><h3 id="具体步骤："><a href="#具体步骤：" class="headerlink" title="具体步骤："></a>具体步骤：</h3><ol><li><p>得利于子杰同学的努力，项目中已经拥有了docker这个文件夹，只需要微调里面存放项目的地址即可；</p></li><li><p>将自己的项目推到gitlab的仓库中，并且将gitlab项目地址、项目的各个环境的域名告诉运维同学；</p></li><li><p>自己摸索到后端的仓库中，找到 config-templates 的项目，在对应的文件夹下面新（fu）建（zhi）好自己的配置文件，可以叫人帮你一起看看配置的对不对，然后发merge-request给运维同学；</p></li><li><p>运维同学给到两样关键数据：（1.）Jenkins项目地址 （2）测试机上面的端口号；</p></li><li><p><strong>Jenkins地址</strong>拿到后在自己的项目里面构建 baseimg 的 tag，只有拥有了baseimg才能走通master和testxx分支的构建；这里需要和运维同学一起联调；</p></li><li><p>测试机上的端口号，将项目本地配置文件中的启动端口号更改成运维同学配置好的端口；通过ssh进入测试机，进入webroot目录中下载你的项目，走一遍yarn；yarn build；yarn pm2……;</p></li></ol><p>第5步是部署测试环境、灰度环境、生产环境</p><p>第6步是部署联调环境</p><p>按照这个流程走下来基本上就么得问题了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> UMI3 Dva Webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吾来-画布功能要点汇总</title>
      <link href="/2020/04/09/%E5%90%BE%E6%9D%A5-%E7%94%BB%E5%B8%83%E5%8A%9F%E8%83%BD%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB/"/>
      <url>/2020/04/09/%E5%90%BE%E6%9D%A5-%E7%94%BB%E5%B8%83%E5%8A%9F%E8%83%BD%E8%A6%81%E7%82%B9%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="要点汇总"><a href="#要点汇总" class="headerlink" title="要点汇总"></a>要点汇总</h1><ul><li>画布的前身今世</li><li>技术选择</li><li>技术实现</li></ul><h2 id="画布的前身今世"><a href="#画布的前身今世" class="headerlink" title="画布的前身今世"></a>画布的前身今世</h2><blockquote><p>画布是任务场景中对于对话单元的设置以及排布的区域，以下介绍对比了画布的演进历史。</p></blockquote><h3 id="DM1时代"><a href="#DM1时代" class="headerlink" title="DM1时代"></a>DM1时代</h3><p>DM1（Dialog Manage 1st version）对话管理 即 任务对话管理第一版本;</p><p>现在（2019.11.25）依然呈现在项目中-任务对话-场景列表-「旧版」场景;</p><p>里面的触发器和对话单元呈现y轴排布，编辑场景对于对话单元的排布要求编辑人员有较高的水准，界面较为简陋，使用起来不是特别得心应手。</p><h3 id="DM1-8时代"><a href="#DM1-8时代" class="headerlink" title="DM1.8时代"></a>DM1.8时代</h3><p>DM1.8 这个数字非常有趣，它不是1也不是2，是一个中间版本;<br>它属于DM2数据的前身，现在已经下线。<br>那为什么会出现这个版本呢？<br>想法来源 : 界面采用了和DM1一模一样的配置，不同点在于，算法团队领先于迭代2个月升级了数据库，升级了算法结构，在非常紧急的情况下需要兼容到DM2的数据结构以及DM1的用户交互，花费1个迭代 + 10.1黄金周的时间完成。</p><h3 id="DM2时代"><a href="#DM2时代" class="headerlink" title="DM2时代"></a>DM2时代</h3><p>DM2（Dialog Manage 2nd version）任务对话管理第二版本<br>现在项目中的主流场景，也是现在维护的重心所在。</p><pre><code>从十月中旬到11.22日上线，由乔岳领衔，张熠、康永胜通力合作，实际开发时间 为（10.27-11.22），胜利上线。</code></pre><h2 id="技术选择"><a href="#技术选择" class="headerlink" title="技术选择"></a>技术选择</h2><p>在DM1的时期，就有非常多的抱怨声音：</p><pre><code>对话单元排布不够直观；找不到自己需要的对话单元；流程必须脑子想；顺序调整麻烦；……</code></pre><p>CEO做出指示</p><blockquote><p>“ 我们要打造一款市面上与众不同的对话编辑产品 ”</p></blockquote><p>于是，DM2的需求就这么拍下来了……</p><p>CEO再指示 “ 我们要在11.22日顺利上线 ”</p><p>于是，DM2需求的截止日期也拍下来了……</p><blockquote><p>鲁迅先生说过：“ 调研技术方案很复杂 ”</p></blockquote><p>的确是这样，按照惯例，我或许想要去扒一扒类似产品的技术栈，然而现实很残酷，我没找到类似产品。</p><p>好的，这难不倒我，我想了别的方法——在谷歌搜索中敲入「可视化操作 js 前端 模块拖拽」等的关键词。</p><p>结果非常喜人，D3.js 作为最高的推荐进入了我的选择。</p><h3 id="D3-js"><a href="#D3-js" class="headerlink" title="D3.js"></a>D3.js</h3><p><a href="https://d3js.org/">https://d3js.org/</a></p><p>D3js作为行业内非常受人关注的可视化工具，里面提供了大量的实例，沉浸在大家开发的各(hua)式(li)各(hu)样(shao)的工具中，我感到异常欣喜——或许调研工作就这么完成了！</p><p>我太天真了</p><p>D3js 它并不是一个开箱即用的工具，丰富的画布操作、酷炫的物理引擎，在他们的背后是一个又一个的数学函数在支撑。尽管我能找到在界面上有95%相近的模板，但是剩下的5%却可能遥不可及。</p><p>在处理了第三个DEMO转换失败之后，我放弃了选用D3js。</p><h3 id="2-Canvas"><a href="#2-Canvas" class="headerlink" title="2. Canvas"></a>2. Canvas</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API">https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API</a></p><p>几乎相同的理由，相比于D3js， Canvas 似乎更加原始，通过丰富的API去展示画布中的信息，但是操纵画布怎么返回信息到前端？</p><p>‘That really makes me confused !’</p><p>闪电般的速度，我就放弃了</p><h3 id="3-JSPlumb"><a href="#3-JSPlumb" class="headerlink" title="3. JSPlumb"></a>3. JSPlumb</h3><p><a href="https://jsplumbtoolkit.com/">https://jsplumbtoolkit.com/</a></p><p>社区版的文档地址</p><p>感叹着 我太南了 的时候，不经意间进入了这个网站。</p><p>哦吼！</p><p>这看似一般的界面下，隐藏四个大字（就是他了）</p><p>那么好处都有啥？</p><ul><li><p>看起来就是个编辑流程的玩意儿；</p></li><li><p>封装了足够多的拖拽连线的事件；</p></li><li><p>提供了足够的API在社区版本中；</p></li></ul><p>澳大利亚的团队好说话，写了个邮件人家就让我免费使用开发版（一个月）；</p><p>距离截止日期又近了几天，要来不及了；</p><p>用简单的DEMO证明了从数据到画布是可行的，在画布中自定义单元的样式也是可行的，免费的，可以在React技术栈中使用可行的，连线的效果设计师看了都👏是可行的……</p><p>没错，最后我选择的技术栈就是使用JSPlumb。</p><h2 id="技术实现"><a href="#技术实现" class="headerlink" title="技术实现"></a>技术实现</h2><p>这是重点，这是重点，这是……</p><h3 id="前端前技术"><a href="#前端前技术" class="headerlink" title="前端前技术"></a>前端前技术</h3><p>框架确定好了，那么根据框架特性，我们要确定一个总体的思想——数据流向问题。</p><p>需求为 做一个可以多版本的可视化的能拖拽的能连线的 画布，细节自己琢磨。</p><p>前端的目光先聚集在“多版本”之后：</p><ul><li><p>可视化：框架已经帮忙做好了；</p></li><li><p>能拖拽：框架也帮忙了；</p></li><li><p>能连线：框架也做好了；</p></li></ul><p>收工！</p><p>然而真的是这样吗？</p><p>我们做一些对话单元的div放在那里，拖进画布中，画布返回结构，如果需要保存那就再做一次映射？</p><p>错，那样的产品不可能免费</p><p>实际上JSPlumb的行为完全是由我们操纵的：</p><p>渲染画布：从数据库中读取数据，按照JSPlumb官网的要求生成所需的数据结构，传递到画布实例中，渲染生成；</p><p>对话单元拖入画布中，放下： 画布监听鼠标放置的位置，返回位置信息（画布左上角为（0,0）向左向下递增），我们修改画布数据，渲染单元；</p><p>对话单元连线：连线需要知道两个端点，数据结构为</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">from</span>: id1, <span class="attr">to</span>: id2&#125;</span><br></pre></td></tr></table></figure><p>相应的，每个对话单元块会有一个自己的block_id，（如果有多种跳转关系）那么每个单元块内部的关系会有自己的relation_id，通过这些id，就能定义好数据结构，修改画布数据，渲染连线。</p><p>由此可见，实际上我们的数据流向是单向的，不必担心画布还会生成一份数据进行糅合处理，永远是外层监听画布内的事件，通过修改渲染画布的数据结构来达到修改画布信息的目的。</p><h3 id="前后端技术"><a href="#前后端技术" class="headerlink" title="前后端技术"></a>前后端技术</h3><h4 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h4><blockquote><p>“画布内要多版本”-产品经理如是说</p></blockquote><p>MySQL的操作过于繁重，不适合做版本的管理。</p><p>经验丰富的康永胜同志果断的学习并且采用MongoDB的技术栈。</p><p>MongoDB拥有轻量的特性，读写速度快，用于画布内的数据存储和版本管理再好不过了，只有在发布画布内信息的时候，MongoDB才会把数据跟MySQL进行一次同步，更新到MySQL当中。</p><h2 id="代码细节"><a href="#代码细节" class="headerlink" title="代码细节"></a>代码细节</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p>└── Visual<br>├── block<br>│ ├── ask.block.tsx<br>│ ├── …<br>│ ├── collect.block.tsx<br>│ ├── …<br>│ └── block.tsx<br>├── common<br>│ ├── bounce.tsx<br>│ ├── dimension.tsx<br>│ ├── header.tsx<br>│ ├── lemma.tsx<br>│ ├── option.tsx<br>│ └── topbar.tsx<br>├── configs<br>│ ├── block.config.ts<br>│ ├── instance.config.ts<br>│ └── jsplumb.config.ts<br>├── forms<br>│ ├── test.form.tsx<br>│ ├── test.style.ts<br>│ ├── trigger.form.tsx<br>│ └── trigger.style.ts<br>├── hoc<br>│ ├── drag.hoc.tsx<br>│ └── endpoint.hoc.tsx<br>├── canvasView.tsx<br>├── controlsView.tsx<br>├── index.tsx<br>├── visual.data.ts<br>└── visual.style.ts</p><h3 id="block"><a href="#block" class="headerlink" title="block"></a>block</h3><p>画布中的对话单元模块，使用的时候有两种模式：</p><ol><li>简单模式：如同询问单元</li></ol><p>只需要传递block的种类</p><ol start="2"><li>复杂模式：如同收集单元<br>如果需要自己画出来，那就得自己render。</li></ol><p>区分简单复杂模式有一个简单的方法，如果这个单元需要填槽，那么大概率他就是一个复杂模式，如果不需要，对话流只需要简单地通过单元，那就是简单模式。</p><h3 id="common"><a href="#common" class="headerlink" title="common"></a>common</h3><p>该目录下放置了一些通用的组件:</p><ul><li><p>bounce.tsx 左侧的抽屉（点击打开关闭）</p></li><li><p>dimension.tsx 下方的缩略图（minimap）</p></li><li><p>header.tsx 画布上方的顶栏（意图名称、设置、发布等等）</p></li><li><p>topbar.tsx 对话单元模块的顶部（对话单元的icon，编辑按钮，删除按钮x）</p></li><li><p>option.tsx 对话单元模块的区域（跳转关系等，使用endpoint.hoc.tsx包裹生成端点间连接能力）</p></li><li><p>lemma.tsx 对话单元模块的区域（默认文案、添加关系等）</p></li></ul><h3 id="configs"><a href="#configs" class="headerlink" title="configs"></a>configs</h3><ul><li><p>block.config.ts 处理对话单元数据（格式化，一些ENUM定义，提取数据中有关单元信息等的文件）</p></li><li><p>instance.config.ts 画布实例配置（全局加锁，用于打开编辑框时）</p></li><li><p>jsplumb.config.ts 画布相关配置（点、线、画布等）</p></li></ul><h3 id="forms"><a href="#forms" class="headerlink" title="forms"></a>forms</h3><p>表单类信息</p><p>test.form(style).ts 编辑对话单元详情的文件，非常非常大，希望以后有谁来拆分出来！</p><p>trigger.form.ts 以前用来编辑触发器的文件</p><h3 id="hoc高阶组件"><a href="#hoc高阶组件" class="headerlink" title="hoc高阶组件"></a>hoc高阶组件</h3><p>drag.hoc.tsx 赋予组件拖动能力，设置对话单元的初始位置（top left），新增端点</p><p>endpoint.hoc.tsx 赋予对话单元模块中的端点能力，包括鼠标进出的效果。</p><h2 id="配合操作"><a href="#配合操作" class="headerlink" title="配合操作"></a>配合操作</h2><p><strong>index.tsx</strong> 作为画布的入口文件，是输出和渲染画布的主要文件。当路由解析到对应画布的路由的时候，index.tsx就被激活了！</p><p>首先会经历一段生命周期，在即将装载的时候会获取一部分数据，以及注册一些方法（展示自动保存）。</p><p>装载完成后有个监听和 pushState 操作，这一步操作是为了防止mac用户在操作电脑的时候「左滑 移动 画布」直接触发历史回退，做了拦截。</p><p>其他都比较常规，属于看看注释就能看懂的。</p><p><strong>visual.data.ts</strong> 是定义了画布内所有接口的文件，基本上在书写画布内代码的时候想要找的接口在这里都能找的！</p><p><strong>visual.style.ts</strong> 画布内的大部分样式都在这里，除了对话单元编辑抽屉 和 触发器编辑抽屉</p><p><strong>controlsView.tsx</strong> 画布页面左侧的对话单元陈列区域，拥有点击添加、拖拽（拖拽起点监听）添加等的能力。</p><p><strong>canvasView.tsx</strong> 画布区域！实例化画布，渲染画布所需要的各种数据结构， 绑定所有建立关联的事件：</p><ul><li><p>鼠标移入；</p></li><li><p>鼠标移出；</p></li><li><p>删除连接；</p></li><li><p>建立连接（分为触发器-对话单元，对话单元-对话单元）；</p></li><li><p>拖拽放置新建(onDrop监听nativeEvent , 通过layerX\Y来确定放置位置等)；</p></li></ul><h2 id="业务迷惑行为学大赏"><a href="#业务迷惑行为学大赏" class="headerlink" title="业务迷惑行为学大赏"></a>业务迷惑行为学大赏</h2><h3 id="1-填槽顺序调整"><a href="#1-填槽顺序调整" class="headerlink" title="1. 填槽顺序调整"></a>1. 填槽顺序调整</h3><p>1.1 什么是填槽顺序？</p><p>如果一个意图中有多个询问单元或多个隐藏单元，在两种情况下，任务机器人需要用户手动进行流程校准才可以保证机器人跳转正常：</p><p>第一种情况：用户的消息可以同时填入多个对话单元对应的槽，这时优先填哪个槽？</p><p>第二种情况：用户的消息能更新意图下的某个词槽，这个词槽没有跟当前停留的单元绑定。这时应该：</p><p>让当前单元处理这条消息，还是：</p><p>让这条消息去填充能够填充的那个词槽，再让流程跳回重新判断</p><p>我们通过规定绑定了词槽的单元顺序（询问单元、隐藏单元）来解决这个问题。对于以上两个问题，只要根据这个顺序确定就可以了。</p><p>对于case A：按照单元顺序，排在前面的优先填</p><p>对于case B：按照单元顺序，如果被更新的词槽在当前词槽前面，就更新词槽；如果在后面，就让当前单元处理这条消息；</p><p>拖动单元前的 “把手” 进行排序；</p><h3 id="1-2-代码层面："><a href="#1-2-代码层面：" class="headerlink" title="1.2 代码层面："></a>1.2 代码层面：</h3><p>在这个功能当中，发挥作用的字段为 <code>first_order</code></p><p>如图中所示，自上而下，降序排列；</p><p>不同于对话单元生成时候增长的 order_id，一开始所有单元的 first_order 都是0，只有 type === ‘BLOCK-ASK’ || type === ‘BLOCK-HIDE’的单元在第一次保存校准值之后才会拥有自己的first_order，而且是递减的降序排列；</p><h2 id="FAQ"><a href="#FAQ" class="headerlink" title="FAQ"></a>FAQ</h2><h3 id="连线的数据结构？"><a href="#连线的数据结构？" class="headerlink" title="连线的数据结构？"></a>连线的数据结构？</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A: [&#123; from: relation_id, to: block_id &#125;......] 从 id 到 id。</span><br></pre></td></tr></table></figure><h3 id="拖拽后块结构之间的连线是怎么实现的？"><a href="#拖拽后块结构之间的连线是怎么实现的？" class="headerlink" title="拖拽后块结构之间的连线是怎么实现的？"></a>拖拽后块结构之间的连线是怎么实现的？</h3><p>A: 连线分为两种模式：1. 画布中拖拽连接；2. 编辑器中设置跳转关系；</p><p>方式不同，但是最后都是通过改变渲染画布中连接关系的数据结构来实现连\删线的。</p><h3 id="是否有画布能承载的最大单元数？"><a href="#是否有画布能承载的最大单元数？" class="headerlink" title="是否有画布能承载的最大单元数？"></a>是否有画布能承载的最大单元数？</h3><p>A: 前端没有做限制，在数据层似乎有个最大数的限制，🎙康师傅？</p><h3 id="单元边上的端点是如何设置的？"><a href="#单元边上的端点是如何设置的？" class="headerlink" title="单元边上的端点是如何设置的？"></a>单元边上的端点是如何设置的？</h3><p>A: JSPlumb提供了方法 jsp.addEndpoint;</p><h3 id="连线上的删除icon是怎么放上去的"><a href="#连线上的删除icon是怎么放上去的" class="headerlink" title="连线上的删除icon是怎么放上去的?"></a>连线上的删除icon是怎么放上去的?</h3><p>A: JSPlumb提供了方法 getInstance().onConnectionOver 去设置;</p><h3 id="每次改变时候草稿自动更新，是做的差量计算吗，都保存了那些值来对比是否改变了并存在哪里了？"><a href="#每次改变时候草稿自动更新，是做的差量计算吗，都保存了那些值来对比是否改变了并存在哪里了？" class="headerlink" title="每次改变时候草稿自动更新，是做的差量计算吗，都保存了那些值来对比是否改变了并存在哪里了？"></a>每次改变时候草稿自动更新，是做的差量计算吗，都保存了那些值来对比是否改变了并存在哪里了？</h3><p>A: 不是。更新的时候就是各自对应的接口的调用、传递、保存，只不过是全局做了一个动画来表示我们刚刚调用过接口；</p><h3 id="拖动时，连接线的变化是如何实现的？"><a href="#拖动时，连接线的变化是如何实现的？" class="headerlink" title="拖动时，连接线的变化是如何实现的？"></a>拖动时，连接线的变化是如何实现的？</h3><p>A: JSPlumb 工具实现好了，只要线连接上，移动对话单元，连接线也可以自己跟着跑；</p><h3 id="左侧拖拽组件是画布自带的吗？拖拽是什么实现的？左侧的展示区域中的对话单元是怎么做到拖动到画布中的？"><a href="#左侧拖拽组件是画布自带的吗？拖拽是什么实现的？左侧的展示区域中的对话单元是怎么做到拖动到画布中的？" class="headerlink" title="左侧拖拽组件是画布自带的吗？拖拽是什么实现的？左侧的展示区域中的对话单元是怎么做到拖动到画布中的？"></a>左侧拖拽组件是画布自带的吗？拖拽是什么实现的？左侧的展示区域中的对话单元是怎么做到拖动到画布中的？</h3><p>A: 左侧展示区域并不是画布内的功能，参照 controlsView.tsx;</p><h3 id="拖拽是给-div-增加了-draggable属性；"><a href="#拖拽是给-div-增加了-draggable属性；" class="headerlink" title="拖拽是给 div 增加了 draggable属性；"></a>拖拽是给 div 增加了 draggable属性；</h3><p>参照canvasView.tsx文件所述，监听了画布区域中的onDrop事件，触发了一个方法</p><p>dropHandle，记录了（新的单元，位置信息，名字，种类等），调用新增对话单元的接口，同时更新树，渲染到画布中，等到接口返回数据，再更新redux中的block-list；</p><h3 id="hover多端点的对应项时候，如何做到对应项的连接线也同样变化？"><a href="#hover多端点的对应项时候，如何做到对应项的连接线也同样变化？" class="headerlink" title="hover多端点的对应项时候，如何做到对应项的连接线也同样变化？"></a>hover多端点的对应项时候，如何做到对应项的连接线也同样变化？</h3><p>A: 参照 block.tsx 中的 option.tsx ，他使用 endpoint.hoc.tsx 高阶组件包裹了每一个跳转关系选项，再联合上 jsplumb.config.tsx 中hover线变色的配置，达成了这个效果；</p><h3 id="底部缩略图如何实现的？"><a href="#底部缩略图如何实现的？" class="headerlink" title="底部缩略图如何实现的？"></a>底部缩略图如何实现的？</h3><p>A: 参照 dimension.tsx 下方的缩略图（minimap）；</p><h3 id="点击还原时，接口返回的值如何对应的，还原出之前的画布？"><a href="#点击还原时，接口返回的值如何对应的，还原出之前的画布？" class="headerlink" title="点击还原时，接口返回的值如何对应的，还原出之前的画布？"></a>点击还原时，接口返回的值如何对应的，还原出之前的画布？</h3><p>A: 返回的数据就和初始拿到的一样即可，就是一次重新打开（渲染）的过程而已；</p><h3 id="画布内块结构位置是怎么保存的？"><a href="#画布内块结构位置是怎么保存的？" class="headerlink" title="画布内块结构位置是怎么保存的？"></a>画布内块结构位置是怎么保存的？</h3><p>A: 画布内的对话单元的位置的改变有三种情况：</p><p>点击左侧展示区对应的对话单元生成；</p><p>拖拽左侧展示区相应的对话单元生成；</p><p>挪动画布中的对话单元；</p><p>画布中还有一个特殊单位：触发器，他的位置只有挪动改变；</p><p><strong>点击</strong>生成的时候，直接按照规则给出当前的pos（x, y），存储到数据中；</p><p><strong>拖拽</strong>生成的时候，通过监听事件onDrop，触发了dropHandle，记录pos（event.layerX, event.layerY）;</p><p><strong>挪动</strong>对话单元、触发器的时候，参照 drag.hoc.tsx JSPlumb 提供了 getInstance().jsp.draggable的api，监听了拖拽的始末时刻，得到数值，调用接口存储；</p><h3 id="在重新打开画布的时候会恢复之前的位置，如何实现？"><a href="#在重新打开画布的时候会恢复之前的位置，如何实现？" class="headerlink" title="在重新打开画布的时候会恢复之前的位置，如何实现？"></a>在重新打开画布的时候会恢复之前的位置，如何实现？</h3><p>A: 拿到数据之后，通过 drag.hoc.tsx 文件中的 render 中的 style，告诉每个对话单元的位置，利用DOM的能力放置每一个对话单元；</p><h3 id="redux都存了什么？"><a href="#redux都存了什么？" class="headerlink" title="redux都存了什么？"></a>redux都存了什么？</h3><p>A: 存了好多东西。</p><p>画布的redux存储的是画布相关操作引起的变化：</p><p>增\删\改对话单元</p><p>初始化跳转关系连接</p><p>增\删\改 跳转关系</p><p>开\关抽屉</p><p>画布加锁</p><p>简而言之分成3类，画布中 对话单元 （block）、画布中 跳转关系 （connection）、界面 UI。</p>]]></content>
      
      
      
        <tags>
            
            <tag> React Redux JsPlumb Dom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>划词标注编辑器开发之旅</title>
      <link href="/2020/04/05/%E5%88%92%E8%AF%8D%E6%A0%87%E6%B3%A8%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91%E4%B9%8B%E6%97%85/"/>
      <url>/2020/04/05/%E5%88%92%E8%AF%8D%E6%A0%87%E6%B3%A8%E7%BC%96%E8%BE%91%E5%99%A8%E5%BC%80%E5%8F%91%E4%B9%8B%E6%97%85/</url>
      
        <content type="html"><![CDATA[<p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gfl5oaitupj314x0u0ahu.jpg" alt=""></p><h1 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h1><p>类似于如何把大象塞进冰箱，句式操作页面总共分为三个大块：</p><ol><li>初始化数据；（打开冰箱门）</li><li>编辑操作；（把大象塞进去）</li><li>存储数据；（关上冰箱门）</li></ol><h1 id="一、初始化步骤"><a href="#一、初始化步骤" class="headerlink" title="一、初始化步骤"></a>一、初始化步骤</h1><p>在一个页面中的句式或许有非常多条（例如任务对话 中的意图触发器），也可能只有一条（任务对话中的填槽句式页面），但是对于句式编辑器来说，一个编辑器对应一条句式。</p><p>那么编辑器肯定不会“无中生有”，它所要展示的内容均来自于接口传递的句式数据。这份数据结构中最重要的几个key分别是”content”、”notations”。”content”代表的是句式中存储的文本信息，而”notations”存储的是句式中的词槽实体信息——包括位置、长度、和对应id。</p><p>因此，在初始化的时候就进行第一次判断——“notations”字段是否为空，如果为空，说明当前句式中并没有词槽实体信息，就是一个纯文本，可以根据”content”中的内容直接展示；如果不为空，则说明有词槽实体，需要对应的替换后再展示给用户。</p><p>替换的方式简单说明一下：”notations”字段接收到的数据是一个数组，里面每一项对应的是一组「词槽slot_id-实体entity_id」，除此之外还有两个字段”start_index”、”length”，”start_index”表示这一组「词槽-实体」对应在存储的句式文本”content”中的下标位置，”length”自然就是代表他们所占的长度，通过这3个数据就能把句式文本中的占位符”[ATID:xx]”替换成为用户喜闻乐见的”@城市:北京”。</p><p>「atInfoStore」，顾名思义，他是一个存储“@”信息的变量。这个是纯前端应用的工具字段，在初始化的过程中也初始化了「atInfoStore」，每当解析完一组完整的「词槽-实体、实体」，就会对应地往「atInfoStore」中推一组数据，key为atid，value为词槽和实体信息，并且有一个原则贯穿其中——只增不减，具体下文中详述。</p><p>那么高亮是怎么做到的？其实文本不是简单的设置<code>&lt;textarea /&gt;\&lt;input /&gt;</code>中的value，句式编辑器是一个<code>&lt;div contenteditable=&quot;true&quot;&gt;...&lt;/div&gt;</code>的开启了编辑功能的div。句式的文本内容”content”其实是作为一个文本节点插入了进去，在上一步初始化词槽实体的过程中将对应的数据使用<code>&lt;span id=&quot;atid&quot;&gt;</code>标签包裹了起来，并且在css中设置<code>&lt;span&gt;</code>标签的不可选中已经背景色的变换就实现了高亮。</p><h1 id="二、修改句式"><a href="#二、修改句式" class="headerlink" title="二、修改句式"></a>二、修改句式</h1><p>修改也分成两种修改：1. 普通的文本输入；2. 增删改「词槽-实体」信息</p><p>第一种没有什么好说的，直接修改的是”content”中的内容；</p><p>第二种展开叙述一下：</p><h2 id="1-增加"><a href="#1-增加" class="headerlink" title="1. 增加"></a>1. 增加</h2><p>句式编辑器监听了输入，每当用户输入”@“符号的时候就会自动记录当前光标的在文本中的位置并且弹出词槽实体选择框，当选择「词槽-实体、实体」完毕之后，句式编辑器先往「atinfoStore」里面推了一条新的数据，key: atid负向增长，value: 还是老样子词槽和实体的信息，同时生成了一个dom节点——<code>&lt;span id=&quot;newatid&quot;&gt;@词槽：实体、实体&lt;/span&gt;</code>，这个dom节点随即插入到了之前记录的位置上，这样一次简单的增加”@”信息的操作就完成了。</p><h2 id="2-改"><a href="#2-改" class="headerlink" title="2. 改"></a>2. 改</h2><p>用户鼠标点击对应的高亮区域，句式编辑器从高亮区域的dom节点<code>&lt;span id=”xxatid“&gt;...&lt;/span&gt;</code>中取出「xxatid」，然后从atInfoStore中读取到对应的「词槽-实体」信息填入到跳出的编辑词槽信息的弹窗内；等到用户修改完毕之后，点击保存会重新走一遍「1. 增加」的流程。需要注意的是，为了避免复杂的页面节点的替换操作，我做的是删除掉原有节点，重新生成新节点插入到原有的位置上，因此，在修改某一处”@”信息时，atInfoStore中的数据会增加一条新的atId对应的词槽实体数据，而不是修改原有「xxatid」对应的信息。</p><h2 id="3-删"><a href="#3-删" class="headerlink" title="3. 删"></a>3. 删</h2><p>这也没说的，删了就没了。</p><h1 id="三、保存句式"><a href="#三、保存句式" class="headerlink" title="三、保存句式"></a>三、保存句式</h1><p>为了简化保存时的计算，我特意在编辑器里面做了判断，所有的修改动作都会被判定为原有的句式发生了变化，哪怕是加了一个字又删除掉。如果句式没有发生改变，直接跳过调用接口；如果发生了改变，那么就发生了以下的操作；<br>我之前说了，在页面上展示的并不是简单的文本，而是文本节点和span包裹的节点，这些信息是无法直接读取且保存到数据库中的，所以第一步就是把HTML元素转换成存储的数据。由于在编辑过程中，所有需要转换的部分都被很好的包裹在了带有id的span标签中，在转换HTML元素的时候我只需要把「span」标签以及标签中的「id」提取出来，id可以对应地从「atInfoStore」中找到词槽-实体信息，而span的存在可以很快的进行占位符「[ATID:xx]」的替换。</p><p>被占位符替换完的数据就可以直接存储到”content”字段当中，而对应地从「atInfoStore」中读取的词槽-实体信息，就被一条一条塞入到”notations”字段当中；<br>最后把它们拼成接口所需要的数据结构，调用graphQL接口提交保存即可；</p><h1 id="背景技术"><a href="#背景技术" class="headerlink" title="背景技术"></a>背景技术</h1><p>句式编辑器使用的是HTML自己本身的<code>contenteditable</code>能力；弹窗则是采用了ant-design的popover；接口是使用了GraphQL的技术；</p><h1 id="效果以及优点"><a href="#效果以及优点" class="headerlink" title="效果以及优点"></a>效果以及优点</h1><p>句式编辑器为定制化需求开发，市面上没有找到现成的可以直接使用的富文本编辑器，这是属于来也科技的编辑器。在时间的证明下，它很好地为任务对话提供了触发和收集词槽的功能，用户不需要使用繁琐的表格进行配置，只需要轻松地输入”@“符号即可快速呼出弹窗选择词槽和实体，极快速地配置以及简单明了的操作界面，在很大程度上降低了用户学习和使用词槽-实体的成本。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>single-spa实现通信</title>
      <link href="/2019/11/14/single-spa%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1/"/>
      <url>/2019/11/14/single-spa%E5%AE%9E%E7%8E%B0%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h1><p>在single-spa大的环境下，每一个子App都是一个独立的个体。独立意味着我们会有如下的几个需求：</p><ul><li>每个应用程序拥有着自己的状态和变量，同时没有应用程序知道另一个应用程序或他们的数据模型的内部状态。总之，每个应用程序被视为黑盒，并且可以由不同的团队进行维护；</li><li>每个应用程序必须能够有一个复杂的状态；</li><li>当你的应用程序之间导航，状态不容有失（因为组件会挂载/卸载）。</li></ul><h1 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h1><h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><p>为了满足这些要求，我已经决定了使用「事件系统」，其中每个应用程序可以选择是否监听其他应用程序发送的事件。这使得每个应用程序可以监听到其他应用程序发生了变化后，只修改自己的状态，以保持它们的隔离状态。</p><p>没有应用程序需要<strong>直接访问</strong>另一个应用程序的状态。</p><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><p>此外，我需要的应用程序分为两个部分。一个是正​​常应用本身（GUI，框架等），另一个“通讯层”是独立模块，可以被门户（portal) <strong>加载/实例化</strong>而与应用状态无关。</p><p>这允许每个应用程序监听和响应事件，即使它们没有挂载。</p><p>每个应用程序都可以按照自己喜欢的方式处理这些事件。唯一的要求是所有的应用程序都同意一个事件格式来发送和接收这些事件。</p><h1 id="方案实现"><a href="#方案实现" class="headerlink" title="方案实现"></a>方案实现</h1><h2 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h2><p>对于这个例子，我决定使用redux，因为它基本上完全满足我的需要：</p><ul><li>抛出事件</li><li>处理事件</li></ul><p>tips：但是这个系统可以使用任何你喜欢的技术。</p><h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><h3 id="概念图"><a href="#概念图" class="headerlink" title="概念图"></a>概念图</h3><p>接下来这是一个图表，它说明了实际发生了什么：<br><img src="https://tva1.sinaimg.cn/large/006y8mN6ly1g8xg0iyewpj30ir0d3my2.jpg" alt=""></p><p>图表中的重要组成信息：</p><ol><li><strong>StoreApps</strong>: 包含状态+业务逻辑。实现可在发生全局事件时由GlobalEventDistributor调用的调度方法。</li><li><strong>GUIApps</strong>: singleSPA 中间件+ UI代码 如 HTML, CSS, Controller等+框架如 React 或 Angular singleSPA中间件+ UI代码</li><li><strong>GlobalEventDistributor</strong>: 可以用来注册Store。向所有存储区发送调度事件。(观察者模式)</li></ol><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>根应用程序引导并加载所有存储区（stores）并实例化它们。这是必要的，因为我们需要通信层(存储区)始终处于活动状态。即使整个应用程序还没有挂载。否则，没有应用程序的特定事件得到处理。</li><li>当应用程序被挂载时，根应用程序向下传递属于各个应用程序的已实例化的存储区。根应用程序还将『对GlobalEventDistributor的引用』传递给应用程序。</li><li>现在，您可以使用dispatch()方法将所有全局事件发送到GlobalEventDistributor，并将所有其他事件发送到本地存储。</li></ol><h1 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h1><p>如前所述，最大的缺点是必须在根应用程序加载时加载所有存储。<br>这样做的原因是，我们正在构建一个项目，该项目将有一个巨大的应用程序状态完全存储在浏览器中。<br>用户可能会在没有任何服务器通信的情况下输入1h的数据，一旦完成，用户通过一次单击将会保存所有内容。</p><p>然而，这不一定是您的用例。例如，如果您只对与当前活动的任何应用程序的应用程序间通信感兴趣，您可能不需要预先加载所有状态，而是在应用程序运行时加载它们。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack学习笔记</title>
      <link href="/2019/09/29/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/09/29/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>webpack的英文文档和<a href="https://webpack.docschina.org/configuration/output">中文文档</a>都非常完善！</p><h1 id="输出（output）"><a href="#输出（output）" class="headerlink" title="输出（output）"></a>输出（output）</h1><h2 id="output-library"><a href="#output-library" class="headerlink" title="output.library"></a>output.library</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>乾坤学习</title>
      <link href="/2019/09/11/%E4%B9%BE%E5%9D%A4/"/>
      <url>/2019/09/11/%E4%B9%BE%E5%9D%A4/</url>
      
        <content type="html"><![CDATA[<p>乾坤是阿里出品的一款基于single-spa搭建的框架，<br>git地址是：<a href="https://github.com/umijs/qiankun">https://github.com/umijs/qiankun</a></p><blockquote><p>乾是天，坤是地，乾坤就是全宇宙</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> qiankun singleSPA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序插件开发</title>
      <link href="/2019/07/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
      <url>/2019/07/16/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h1 id="小程序插件"><a href="#小程序插件" class="headerlink" title="小程序插件"></a>小程序插件</h1><p>以目录结构为主简单介绍，注意，doc miniprogram plugin 名称均不可更改。</p><h2 id="doc"><a href="#doc" class="headerlink" title="doc"></a>doc</h2><p>该目录下存放的是小程序插件必备的说明文档“README.md”以及文档所需的图片，注意该目录下的README.md在微信小程序开发工具中需要单独提交。</p><h2 id="miniprogram"><a href="#miniprogram" class="headerlink" title="miniprogram"></a>miniprogram</h2><p>小程序插件开发的主体。</p><p>小程序插件必须依赖一个主体（小程序），因此在开发过程中会需要一个小程序，这个目录下的小程序就是模拟之后调用者的小程序。</p><p>不必担心提交的时候携带上这个目录会影响插件，因为微信官方审核的时候也是需要通过开发者在当前目录下写的小程序调用小程序插件来进行判断是否符合规范等。</p><h2 id="plugin"><a href="#plugin" class="headerlink" title="plugin"></a>plugin</h2><p>小程序插件开发的真正区域。</p><h3 id="api"><a href="#api" class="headerlink" title="api"></a>api</h3><p>小程序插件对外可调用的api，可以在miniprogram目录下找到调用插件的地方结合起来理解。</p><p>一般来说这里可以不用动。</p><h3 id="pages"><a href="#pages" class="headerlink" title="pages"></a>pages</h3><p>小程序插件的页面，虽然可以用多个，但是在吾来对话机器人插件中用不着，因此就只有一个chat页面，里面有小程序插件本体的HTML、CSS、JS。</p><h4 id="chat"><a href="#chat" class="headerlink" title="chat"></a>chat</h4><p>按照生命周期了解功能。</p><ol><li><p>首先进入插件后就触发 <code>ready</code> 这个生命周期钩子；<br>在这个生命周期内进行了一系列操作：</p><ul><li>把调用方传递参数本地化；</li><li>判断是否已经登录，如果调用方在吾来后台把调用者的小程序的appId和appSecret传递给我们了，那么如果调用方传递的参数<code>username: &#39;&#39;</code>，那么我们就可以帮忙做登录，如果调用方自己有能力，就可以自己登录完毕，把登录完毕换回的<code>openid</code>存在<code>username</code>字段中传递给插件，详情请阅读doc下的README.md;</li><li>登陆完毕之后调用<code>startWork</code>开始插件的基础设置——是否展示历史消息、头像是什么、气泡什么样……详情请参见<a href="http://openapi-docs-inner.wul.ai/docs/1.9.0/channel_backend/channel_backend.html#operation/Start">后端开放平台接口</a></li></ul><p>登录操作和启动操作都完成后就可以开始工作了。</p></li></ol><h3 id="components"><a href="#components" class="headerlink" title="components"></a>components</h3><p>页面要调用的组件，小程序调用插件的方法可以查阅官方文档</p><p>工具类: module-*<br>消息类型: msg-*<br>用户消息: user-msg<br>机器人回复: bot-msg<br>提示消息组件: notice-msg</p><p>代码内部做了详细的注释，阅读起来应该没有很大的问题。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>一些静态文件，小图标等，大的图片考虑上传阿里云；</p><h3 id="utils"><a href="#utils" class="headerlink" title="utils"></a>utils</h3><h4 id="constant-js"><a href="#constant-js" class="headerlink" title="constant.js"></a>constant.js</h4><p>存放了一些常量：</p><ul><li>接口的path</li><li>项目内常用的一些常量（看见大写的变量不懂的话来这里看看）</li></ul><h4 id="env-js"><a href="#env-js" class="headerlink" title="env.js"></a>env.js</h4><p>按照注释做，用于区分测试环境还是灰度正式环境，影响到的是后端接口的host</p><h4 id="promisify-js"><a href="#promisify-js" class="headerlink" title="promisify.js"></a>promisify.js</h4><p>封装了promise方法，想要调用Promise请求的时候可以考虑从这里引用。</p><h4 id="request-js"><a href="#request-js" class="headerlink" title="request.js"></a>request.js</h4><p>封装了POST和GET方法</p><h4 id="util-js"><a href="#util-js" class="headerlink" title="util.js"></a>util.js</h4><p>封装了一些项目中通用的方法</p><h4 id="watch-js"><a href="#watch-js" class="headerlink" title="watch.js"></a>watch.js</h4><p>ohhhhh,这个文件没啥用。</p><hr><p>以上就是对于小程序插件的介绍，相关配置<code>project.config.json</code> <code>plugin.json</code> <code>app.json</code>可以通过官方文档对照学习使用，很easy的。</p><h1 id="如何应对定制化"><a href="#如何应对定制化" class="headerlink" title="如何应对定制化"></a>如何应对定制化</h1><p>定制化需要考虑功能是否是必须从基础版本中脱离出来的，如果是，那么继续。</p><h2 id="需要一个新的插件"><a href="#需要一个新的插件" class="headerlink" title="需要一个新的插件"></a>需要一个新的插件</h2><p>这意味着需要一份新鲜的代码<br><a href="https://gitlab.com/laiye-frontend-repos/wechat-sdk">吾来小程序插件Gitlab地址</a><br>进入并且Fork到新的仓库中，仍然会进行开发。</p><p>代码有了，还需要一个<a href="https://mp.weixin.qq.com/">微信后台账号</a>，找到负责的产品去新建就完了。</p><p>新建完毕之后按照正常小程序插件开发流程去配置，下载一个‘微信小程序开发工具’进行本地的开发即可。</p><h2 id="如果需要更新"><a href="#如果需要更新" class="headerlink" title="如果需要更新"></a>如果需要更新</h2><p>Fork的版本如果想要更新到通用版的某个更加新的版本，可以通过新建Merge Request来解决。</p><h2 id="定制化"><a href="#定制化" class="headerlink" title="定制化"></a>定制化</h2><h3 id="保乐力加定制化"><a href="#保乐力加定制化" class="headerlink" title="保乐力加定制化"></a>保乐力加定制化</h3><h4 id="需求："><a href="#需求：" class="headerlink" title="需求："></a>需求：</h4><ol><li>可以在插件内部点击消息中的链接跳转到<strong>调用方小程序</strong>内部的某个页面；</li><li>可以在插件内部点击消息中的链接跳转到<strong>其他的小程序</strong>的某个页面；</li></ol><hr><h4 id="跳转方案："><a href="#跳转方案：" class="headerlink" title="跳转方案："></a>跳转方案：</h4><p>小程序插件开发有诸多限制，小程序插件的wx对象和调用者的wx（后面用WX来表示）对象是不同的，在官方文档中插件内部的跳转的api虽然不被限制，但是实际的效果却是只能在小程序插件内部的页面中切换跳转。</p><p>因此采用了HACK的方式，在小程序插件内部获取到了调用方小程序的 WX 对象。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 调用方的js文件 --&gt;</span><br><span class="line">plugin.init(wulAiSDK, wx, pubkey, userInfo);</span><br><span class="line"></span><br><span class="line">&lt;!-- 小程序插件内部调用WX --&gt;</span><br><span class="line">&lt;!-- 需求<span class="number">1</span> --&gt;</span><br><span class="line">WX.navigateTo()</span><br><span class="line">&lt;!-- 需求<span class="number">2</span> --&gt;</span><br><span class="line">WX.navigateToMiniProgram()</span><br></pre></td></tr></table></figure><h4 id="触发跳转方案"><a href="#触发跳转方案" class="headerlink" title="触发跳转方案"></a>触发跳转方案</h4><p>在已有的消息类型，如CUSTOM消息类型中的content字段中存储上跳转所需的<code>appId pathUrl</code>等所需信息，当有这个类型的消息到达时，在对应的 “/components/msg-custom”（新建）组件中去处理content字段中携带的信息，并且以链接的形式呈现在消息卡片中，当用户点击的时候触发方法进行跳转。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信小程序插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Single-Spa学习</title>
      <link href="/2019/07/15/Single-Spa%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/07/15/Single-Spa%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="触摸single-spa之道"><a href="#触摸single-spa之道" class="headerlink" title="触摸single-spa之道"></a>触摸single-spa之道</h1><h2 id="什么是single-spa？"><a href="#什么是single-spa？" class="headerlink" title="什么是single-spa？"></a>什么是single-spa？</h2><blockquote><p>single-spa是一个在前端应用程序中汇集多个javascript微内容的框架。 使用single-spa构建您的前端可带来许多好处，例如：</p></blockquote><blockquote><ul><li>在同一页面上使用多个框架而无需刷新页面（React，AngularJS，Angular，Ember或您正在使用的任何内容）</li><li>独立部署微内容。</li><li>使用新框架编写代码，而无需重写现有应用程序</li><li>延迟加载代码，用于改善初始加载时间。</li></ul></blockquote><h3 id="诞生概述"><a href="#诞生概述" class="headerlink" title="诞生概述"></a>诞生概述</h3><p>single-spa通过将生命周期应用于整个应用程序，从现代框架组件生命周期中获取灵感。 它的诞生起源于Canopy希望使用 <code>React + react-router</code> 而不是永远坚持使用我们的<code>AngularJS + ui-router</code>应用程序，现在single-spa支持几乎所有框架。<br>    由于JavaScript因其众多框架的短命而臭名昭着，因此single-spa的设计者决定让开发者们想要的任何框架都很容易。</p><ol><li><p>应用程序，每个应用程序本身就是一个完整的SPA（有点）。 每个应用程序都可以响应url路由事件，并且必须知道如何从DOM引导，装载和卸载它们。 传统SPA和单一spa应用程序之间的主要区别在于它们必须能够与其他应用程序共存，并且它们不是每个都有自己的html页面。</p><p>例如，您的React或Angular SPA是应用程序。 处于活动状态时，它们会侦听URL路由事件并将内容放在DOM上。 处于非活动状态时，它们不会侦听url路由事件，而是完全从DOM中删除。</p></li></ol><ol start="2"><li>单个spa-config，它是html页面和使用single-spa注册应用程序的JavaScript。 每个应用程序都注册了三件事：</li></ol><ul><li>一个名字</li><li>加载应用程序代码的函数</li><li>用于确定应用程序何时处于活动/非活动状态的功能</li></ul><h3 id="很难使用吗？"><a href="#很难使用吗？" class="headerlink" title="很难使用吗？"></a>很难使用吗？</h3><h4 id="从技术栈架构上来说"><a href="#从技术栈架构上来说" class="headerlink" title="从技术栈架构上来说"></a>从技术栈架构上来说</h4><p>single-spa适用于 ES5，ES6 +，TypeScript，Webpack，SystemJS，Gulp，Grunt，Bower，ember-cli或任何可用的构建系统。 开发者可以通过npm安装它，jspm安装它，或者如果愿意，甚至只需使用<script>标记。</p><p>作者的目标是尽可能简单地使用single-spa。<br>但作者也指出，这是一种先进的架构，与前端应用程序的典型工作方式不同。</p><h4 id="从浏览器层面来说"><a href="#从浏览器层面来说" class="headerlink" title="从浏览器层面来说"></a>从浏览器层面来说</h4><p>single-spa适用于Chrome，Firefox，Safari，IE11和Edge。</p><h2 id="储备知识"><a href="#储备知识" class="headerlink" title="储备知识"></a>储备知识</h2><p>这里记录我在阅读了官网文档已经一些最佳实践之后归纳出的储备知识。<br>对于前端来说，要解决的问题一般分为两种阶段:</p><ol><li>开发阶段；</li><li>部署阶段；</li></ol><p>其中开发阶段要解决：</p><ol><li>第三方包的安装、使用、依赖的维护；</li><li>自有代码的维护和使用；</li></ol><h3 id="SystemJs"><a href="#SystemJs" class="headerlink" title="SystemJs"></a>SystemJs</h3><p>为什么要用 SystemJS ？<br>因为如果在项目中如果只使用单一规范，比如针对 AMD，我们可能会用 RequireJS；ES6 的模块，我们可能会用到 ES6 Module Loader Polyfill；CommonJS 规范的模块，我们可能用 SystemJS – 它同样可用于加载 AMD/ES6 模块。<br>systemjs 是一个最小系统加载工具，用来创建插件来处理可替代的场景加载过程，包括加载 CSS 场景和图片，主要运行在浏览器和 NodeJS 中。它是 ES6 浏览器加载程序的的扩展，将应用在本地浏览器中。通常创建的插件名称是模块本身，要是没有特意指定用途，则默认插件名是模块的扩展名称。</p><p>通常它支持创建的插件种类有：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># CSS </span><br><span class="line">System.import(<span class="string">&#x27;my/file.css!&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># Image </span><br><span class="line">System.import(<span class="string">&#x27;some/image.png!image&#x27;</span>)</span><br><span class="line"></span><br><span class="line"># JSON </span><br><span class="line">System.import(<span class="string">&#x27;some/data.json!&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>)</span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"># Markdown </span><br><span class="line">System.import(<span class="string">&#x27;app/some/project/README.md!&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">html</span>) </span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"># Text </span><br><span class="line">System.import(<span class="string">&#x27;some/text.txt!text&#x27;</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">text</span>) </span>&#123;&#125;)</span><br><span class="line"></span><br><span class="line"># WebFont </span><br><span class="line">System.import(<span class="string">&#x27;google Port Lligat Slab, Droid Sans !font&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>划词标注编辑器开发之旅</title>
      <link href="/2019/07/10/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/"/>
      <url>/2019/07/10/%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h1 id="前端代码规范"><a href="#前端代码规范" class="headerlink" title="前端代码规范"></a>前端代码规范</h1><ul><li>使用字面语法来创建对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> item = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> item = &#123;&#125;;</span><br></pre></td></tr></table></figure><ul><li>在对象声明的时候将简写的属性进行分组。</li></ul><blockquote><p>为什么? 这样更容易的判断哪些属性使用的简写。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> anakinSkywalker = <span class="string">&#x27;Anakin Skywalker&#x27;</span>;</span><br><span class="line"><span class="keyword">const</span> lukeSkywalker = <span class="string">&#x27;Luke Skywalker&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  episodeOne: <span class="number">1</span>,</span><br><span class="line">  twoJediWalkIntoACantina: <span class="number">2</span>,</span><br><span class="line">  lukeSkywalker,</span><br><span class="line">  episodeThree: <span class="number">3</span>,</span><br><span class="line">  mayTheFourth: <span class="number">4</span>,</span><br><span class="line">  anakinSkywalker,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  lukeSkywalker,</span><br><span class="line">  anakinSkywalker,</span><br><span class="line">  episodeOne: <span class="number">1</span>,</span><br><span class="line">  twoJediWalkIntoACantina: <span class="number">2</span>,</span><br><span class="line">  episodeThree: <span class="number">3</span>,</span><br><span class="line">  mayTheFourth: <span class="number">4</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>尽量使用对象扩展操作符，而不是用 Object.assign 浅拷贝一个对象。 使用对象的 rest 操作符来获得一个具有某些属性的新对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// very bad</span></span><br><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(original, &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;); <span class="comment">// 变异的 `original` ಠ_ಠ</span></span><br><span class="line"><span class="keyword">delete</span> copy.a; <span class="comment">// 这....</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = <span class="built_in">Object</span>.assign(&#123;&#125;, original, &#123; <span class="attr">c</span>: <span class="number">3</span> &#125;); <span class="comment">// copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> original = &#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> copy = &#123; ...original, <span class="attr">c</span>: <span class="number">3</span> &#125;; <span class="comment">// copy =&gt; &#123; a: 1, b: 2, c: 3 &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; a, ...noA &#125; = copy; <span class="comment">// noA =&gt; &#123; b: 2, c: 3 &#125;</span></span><br></pre></td></tr></table></figure><ul><li>如果数组有多行，则在开始的时候换行，然后在结束的时候换行。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> arr = [</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectInArray = [&#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  id: <span class="number">2</span>,</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numberInArray = [</span><br><span class="line">  <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> arr = [[<span class="number">0</span>, <span class="number">1</span>], [<span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectInArray = [</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    id: <span class="number">2</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numberInArray = [</span><br><span class="line">  <span class="number">1</span>,</span><br><span class="line">  <span class="number">2</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure><ul><li>对于多个返回值使用对象解构，而不是数组解构。</li></ul><blockquote><p>为什么? 你可以随时添加新的属性或者改变属性的顺序，而不用修改调用方。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理代码...</span></span><br><span class="line">  <span class="keyword">return</span> [left, right, top, bottom];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用者需要考虑返回数据的顺序。</span></span><br><span class="line"><span class="keyword">const</span> [left, __, top] = processInput(input);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processInput</span>(<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 处理代码...</span></span><br><span class="line">  <span class="keyword">return</span> &#123; left, right, top, bottom &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用者只选择他们需要的数据。</span></span><br><span class="line"><span class="keyword">const</span> &#123; left, top &#125; = processInput(input);</span><br></pre></td></tr></table></figure><ul><li>使用默认的参数语法，而不是改变函数参数。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// really bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// still bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (opts === <span class="keyword">void</span> <span class="number">0</span>) &#123;</span><br><span class="line">    opts = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总是把默认参数放在最后。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">opts = &#123;&#125;, name</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handleThings</span>(<span class="params">name, opts = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>尽量使用 class. 避免直接操作 prototype .</li></ul><blockquote><p>为什么? class 语法更简洁，更容易推理。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span>(<span class="params">contents = []</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.queue = [...contents];</span><br><span class="line">&#125;</span><br><span class="line">Queue.prototype.pop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="built_in">this</span>.queue[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">this</span>.queue.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">contents = []</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.queue = [...contents];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">pop</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.queue[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">this</span>.queue.splice(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不要使用迭代器。 应该使用 JavaScript 的高阶函数代替 for-in 或者 for-of</li></ul><blockquote><p> 拥有返回值得纯函数比这个更容易解释。<br>使用 map() / every() / filter() / find() / findIndex() / reduce() / some() / … 遍历数组， 和使用 Object.keys() / Object.values() / Object.entries() 迭代你的对象生成数组。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> num <span class="keyword">of</span> numbers) &#123;</span><br><span class="line">  sum += num;</span><br><span class="line">&#125;</span><br><span class="line">sum === <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">numbers.forEach(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  sum += num;</span><br><span class="line">&#125;);</span><br><span class="line">sum === <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// best (use the functional force)</span></span><br><span class="line"><span class="keyword">const</span> sum = numbers.reduce(<span class="function">(<span class="params">total, num</span>) =&gt;</span> total + num, <span class="number">0</span>);</span><br><span class="line">sum === <span class="number">15</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> increasedByOne = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; numbers.length; i++) &#123;</span><br><span class="line">  increasedByOne.push(numbers[i] + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> increasedByOne = [];</span><br><span class="line">numbers.forEach(<span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  increasedByOne.push(num + <span class="number">1</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// best (keeping it functional)</span></span><br><span class="line"><span class="keyword">const</span> increasedByOne = numbers.map(<span class="function"><span class="params">num</span> =&gt;</span> num + <span class="number">1</span>);</span><br></pre></td></tr></table></figure><ul><li>把 const 声明的放在一起，把 let 声明的放在一起。</li></ul><blockquote><p>为什么? 这在后边如果需要根据前边的赋值变量指定一个变量时很有用</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> i, len, dragonball,</span><br><span class="line">    items = getItems(),</span><br><span class="line">    goSportsTeam = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"><span class="keyword">const</span> items = getItems();</span><br><span class="line"><span class="keyword">let</span> dragonball;</span><br><span class="line"><span class="keyword">const</span> goSportsTeam = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">let</span> len;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> goSportsTeam = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> items = getItems();</span><br><span class="line"><span class="keyword">let</span> dragonball;</span><br><span class="line"><span class="keyword">let</span> i;</span><br><span class="line"><span class="keyword">let</span> length;</span><br></pre></td></tr></table></figure><ul><li>使用定义变量的时候把它们放在一个合理的地方。<blockquote><p>let 和 const 是块级作用域而不是函数作用域。</p></blockquote></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad - 不必要的函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkName</span>(<span class="params">hasName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (hasName === <span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.setName(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkName</span>(<span class="params">hasName</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasName === <span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> name = getName();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">&#x27;test&#x27;</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.setName(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Http请求的深入了解</title>
      <link href="/2019/07/10/Http%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/"/>
      <url>/2019/07/10/Http%E8%AF%B7%E6%B1%82%E7%9A%84%E6%B7%B1%E5%85%A5%E4%BA%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>content-disposition: attachment;<br>就可以直接下载了</p>]]></content>
      
      
      
        <tags>
            
            <tag> Http,前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React-Fiber学习笔记</title>
      <link href="/2019/07/01/React-Fiber%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/07/01/React-Fiber%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>React Fiber 是 React 核心算法的持续重新实现。这是React团队两年多研究的成果。</p><p>React Fiber 的目标是提高其适合动画、布局和手势等区域的能力。其主功能是增量渲染:能够将渲染工作拆分为块并将其分散到多个帧上。</p><p>其他关键功能包括:</p><ol><li>当新更新进来时，可以暂停、中止或重用工作;</li><li>能够为不同类型的更新分配优先级;</li><li>和新的并发基元。</li></ol><h1 id="关于这篇文档"><a href="#关于这篇文档" class="headerlink" title="关于这篇文档"></a>关于这篇文档</h1><p><code>Fiber</code>引入了几个新颖的概念，单靠查看代码是很难解决的。<br>这也是一项正在进行中的工作。<code>Fiber</code>是一个正在进行的项目，在完成之前可能会进行重大的重构。这篇文档是在这里记录它的设计。</p><h1 id="先决条件"><a href="#先决条件" class="headerlink" title="先决条件"></a>先决条件</h1><p>我强烈建议您在继续之前熟悉以下资源:</p><ul><li><a href="https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html">React组件、元素和实例</a> - “组件”通常是一个重载的术语。牢牢把握这些条款至关重要。</li><li><a href="https://zh-hans.reactjs.org/docs/reconciliation.html">协调</a> - React 对帐算法的高级描述。</li><li><a href="https://github.com/reactjs/react-basic">React基本理论概念</a> - 无实现负担的响应概念模型的描述。其中一些在一读时可能没有意义。没关系，随着时间的推移，它更有意义。</li><li><a href="https://zh-hans.reactjs.org/docs/design-principles.html">React设计原则</a> - 特别注意<a href="https://zh-hans.reactjs.org/docs/design-principles.html#scheduling">协调</a>部分。它做了很好的解释React Fiber的原因。</li></ul><h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><hr><p>如果您尚未查看先决条件部分。</p><p>在深入探讨新事物之前，让我们先回顾一下概念。</p><h2 id="什么是协调（reconciliation）"><a href="#什么是协调（reconciliation）" class="headerlink" title="什么是协调（reconciliation）?"></a>什么是协调（reconciliation）?</h2><h3 id="协调（reconciliation）"><a href="#协调（reconciliation）" class="headerlink" title="协调（reconciliation）"></a>协调（reconciliation）</h3><p>React 算法用于将一个树与另一个树进行差异，以确定需要更改哪些部分。</p><h3 id="更新（update）"><a href="#更新（update）" class="headerlink" title="更新（update）"></a>更新（update）</h3><p>用于渲染 React 应用的数据的更改。通常是”setState”的结果。最终导致重新渲染。<br>React 的 API 的核心思想是将更新视为导致整个应用重新渲染。这允许开发人员以声明性方式推理，而不是担心如何有效地将应用从任何特定状态转换到另一种状态(A 到 B，B 到 C，C 到 A，等等)。</p><p>实际上，在每个更改上重新渲染整个应用仅适用于最琐碎的应用;在真实应用中，性能成本高得令人望而却步。React 具有优化功能，可创建整个应用重新渲染的外观，同时保持出色的性能。这些优化的大部分都是称为协调的过程的一部分。</p><p>协调<code>Scheduling</code>是通常理解为”虚拟 DOM”背后的算法，高级描述如下所示:当您渲染 React 应用程序时，将生成描述该应用程序的节点树并将其保存在内存中。然后，此树将刷新到渲染环境 —— 例如，在浏览器应用程序的情况下，它将转换为一组 DOM 操作。更新应用时(通常通过 setState)将生成一个新树。新树与上一个树有差异，以计算更新渲染的应用所需的操作。</p><p>尽管<code>Fiber</code>是对协调器的一个基础重写，但 React 文档中描述的高级算法将大致相同。要点如下:</p><ul><li>假定不同的组件类型生成完全不同的树。React 不会尝试将它们分散，而是完全替换旧树。</li><li>使用key执行列表差异对比的时候，key应具备”稳定、可预测和唯一”的特性。</li></ul><h2 id="协调与渲染（Reconciliation-versus-rendering）"><a href="#协调与渲染（Reconciliation-versus-rendering）" class="headerlink" title="协调与渲染（Reconciliation versus rendering）"></a>协调与渲染（Reconciliation versus rendering）</h2><p>DOM 只是 React 可以渲染到的渲染环境之一，其他主要目标是通过响应原生进行本机的本机 iOS 和 Android 视图。(这就是为什么有点用错”虚拟 DOM”。）</p><p>它可以支持这么多目标的原因是，React 的设计是使对帐和渲染是单独的阶段。协调者执行计算树的哪些部分已更改的工作;然后，渲染程序使用该信息实际更新渲染的应用。</p><p>这种分离意味着 React DOM 和 React Native 可以在共享由 React 核心提供的同一协调器时使用自己的渲染器。</p><p><code>Fiber</code> 重新实现协调器。它主要与渲染无关，尽管渲染器需要更改以支持(和利用)新的体系结构。</p><h2 id="协调（Scheduling）"><a href="#协调（Scheduling）" class="headerlink" title="协调（Scheduling）"></a>协调（Scheduling）</h2><h3 id="协调"><a href="#协调" class="headerlink" title="协调"></a>协调</h3><p>确定何时应执行工作的过程。</p><h3 id="工作（Work）"><a href="#工作（Work）" class="headerlink" title="工作（Work）"></a>工作（Work）</h3><p>必须执行的任何计算。工作通常是更新的结果(例如 setState)。</p><blockquote><p>在其当前实现中，React 递归遍历整棵Dom树，并在单个变化期间内调用整个更新树的渲染函数。但是，将来它可能会开始延迟某些更新以避免删除帧。<br>这是 React 设计中的一个常见主题。一些流行的库实现了”Push”方法，其中在新数据可用时就执行计算。但是，React 要坚持”Pull”方法，即计算可以推迟到必要的时刻再进行。<br>React 不是通用数据处理库。它是用于构建用户界面的库。我们认为，它在应用中处于独特的位置，可以知道哪些计算现在相关，哪些不相关。<br>如果某些内容位于屏幕外，我们可以延迟与它相关的任何逻辑。如果数据到达速度比帧速率快，我们可以合并和批量更新。我们可以将来自用户交互(如按钮单击引起的动画)的工作优先于不太重要的后台工作(例如渲染刚从网络加载的新内容)，以避免删除帧。</p></blockquote><p>要点如下:</p><ul><li>在 UI 中，不必立即应用每个更新;事实上，这样做可能会浪费，导致帧下降和降低用户体验。</li><li>不同类型的更新具有不同的优先级 - 动画更新需要比来自数据存储的更新更快地完成。</li><li>基于推送的方法要求应用(您，程序员)决定如何安排工作。基于拉取的方法使框架(React)变得智能，并为您做出这些决策。</li></ul><p>React 目前没有以明显地表示要使用该计划;一次更新会导致立即重新渲染整个子树。利用协调是 <code>Fiber</code> 背后的驱动理念就是重构React的核心算法。</p><hr><p>现在，我们已准备好深入了解<code>Fiber</code>的实现。接下来提到的内容比我们到目前为止讨论的内容更具有技术性。</p><h1 id="什么是Fiber？"><a href="#什么是Fiber？" class="headerlink" title="什么是Fiber？"></a>什么是Fiber？</h1><p>接下来即将讨论React Fiber架构的核心，<code>Fiber</code>是一个比应用程序开发人员通常认为的低级抽象的概念，如果你发现自己在试图理解它时感到沮丧，不要感到气馁。不断尝试，你做的努力最终都会有意义。</p><hr><p>我们已经确定 <code>Fiber</code> 的主要目标是使 React 能够利用协调。具体来说，我们需要能够</p><ul><li>暂停工作，然后过一会再回来。</li><li>为不同类型的工作分配优先级。</li><li>重用以前完成的工作。</li><li>如果不再需要操作了，则中止工作。</li></ul><p>为了做到这一点，我们首先需要一种方法，将工作分解为单元。从某种意义上说，这就是<strong>纤维（<code>Fiber</code>）</strong>。一个纤维表示一个工作单元。</p><p>更进一步，让我们回到 React 组件作为数据函数的概念，通常表示为： v = f(d)</p><p>因此，呈现 React 应用类似于调用其正文包含对其他函数的调用的函数，等等。这种类比在思考<code>Fiber</code>时很有用。</p><p>计算机通常跟踪程序执行的方式是使用调用堆栈。执行函数时，将新堆栈帧添加到堆栈中。该堆栈帧表示该函数执行的工作。</p><p>在处理 UI 的时候，可能出现问题是，如果一次执行的工作太多，就会导致动画丢弃帧并看起来不连贯。此外，如果某些操作被较新的更新取代，那么这些较旧的操作可能就没有必要。这就是 UI 组件和函数之间的比较大不相同的地方，因为组件比一般函数更具体。</p><p>较新的浏览器(和React Native)实现 API，来帮助解决这一确切问题:<br>请求 IdleCallback 计划在空闲期间调用低优先级函数，并请求动画Frame 计划在下一个调用高优先级函数动画帧。</p><p>问题是，为了使用这些 API，工程师们需要一种将渲染工作分解为增量单元的方法。如果仅依赖调用堆栈，它将继续工作，直到堆栈为空。</p><p>思考痛点：</p><ul><li>如果我们能够自定义调用堆栈的行为以优化渲染 UI，这难道不是很棒吗?</li><li>如果我们能随时中断调用堆栈并手动操作堆栈帧，这难道不是很棒吗?</li></ul><p>这就是React Fiber的目的，<code>Fiber</code>是堆栈的重新实现，专门用于React组件。您可以将单个<code>Fiber</code>视为<strong>虚拟堆栈框架</strong>。</p><p>重新实现堆栈的优点是可以将堆栈框架保留在内存中，并在需要时执行它们。这对实现我们实现计划目标至关重要。</p><p>除了<strong>协调</strong>之外，手动处理堆栈框架可以释放并发和错误边界等功能的潜力。本文将在之后的部分中介绍这些主题。</p><p>在下一节中，文章将更多地介绍<code>Fiber</code>的结构。</p><h2 id="Fiber的结构"><a href="#Fiber的结构" class="headerlink" title="Fiber的结构"></a>Fiber的结构</h2><p><em>注意:随着React对实现细节的更具体的了解，某些内容可能更改的可能性增加，文章内部的内容不能完全代表最新的React Fiber技术</em></p><p>具体而言，<code>Fiber</code>是一个 JavaScript 对象，其中包含有关组件、其输入及其输出的信息。</p><p><code>Fiber</code>对应于堆栈框架，但它也对应于组件的实例。</p><p>下面是属于<code>Fiber</code>的一些重要字段。(此列表并非详尽列出所有字段奥）</p><h3 id="type-and-key"><a href="#type-and-key" class="headerlink" title="type and key"></a><code>type</code> and <code>key</code></h3><p><code>Fiber</code>的类型和键与”React”元素的用途相同。(事实上，当从元素创建<code>Fiber</code>时，这两个字段将直接复制到该字段上。</p><p><code>Fiber</code>的类型描述它对应的组件。对于复合组件，类型是函数或类组件本身。对于主机组件(div、span 等)，类型是字符串。</p><p>从概念上讲，类型是函数(如 v = f(d))，其执行被堆栈框架跟踪。</p><p>与类型一起，键<code>key</code>在调节期间使用，以确定是否可以重复使用<code>Fiber</code>。</p><h3 id="child-and-sibling"><a href="#child-and-sibling" class="headerlink" title="child and sibling"></a><code>child</code> and <code>sibling</code></h3><p>这些字段指向其他Fiber,描述了Fiber的递归树结构。</p><p><code>子Fiber</code>对应于组件的渲染方法返回的值。因此,在下面的示例中</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child</span> /&gt;</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Parent</code>的子Fiber(子元素)对应于<code>Child</code>。</p><p>同级字段用于呈现返回多个子级的情况(<code>Fiber</code>中的新功能!):</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="xml"><span class="tag">&lt;<span class="name">Child1</span> /&gt;</span></span>, <span class="xml"><span class="tag">&lt;<span class="name">Child2</span> /&gt;</span></span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>子Fiber</code>形成一个单独链接的列表,其头是第一个子元素。因此,在此示例中,<code>Parent</code>的子项为<code>Child1</code>,<code>Child1</code>的同级为<code>Child2</code>。</p><p>回到我们的函数类比,您可以将<code>子Fiber</code>视为 <a href="https://en.wikipedia.org/wiki/Tail_call">tail-called function</a></p><h3 id="return"><a href="#return" class="headerlink" title="return"></a><code>return</code></h3><p><code>return Fiber</code>是程序在处理当前<code>Fiber</code>后应返回的<code>Fiber</code>。它在概念上与堆栈框架的返回地址相同。也可以将其视为<code>parent Fiber</code>。</p><p>如果<code>Fiber</code>有多个<code>child Fibers</code>,则每个<code>child Fiber</code>的<code>return Fiber</code>是<code>parent Fiber</code>。因此,在上一节中的示例中,<code>child 1</code> 和<code>child 2</code>的<code>return Fiber</code>是<code>parent Fiber</code>。</p><h3 id="pendingProps-和memoizedProps"><a href="#pendingProps-和memoizedProps" class="headerlink" title="pendingProps 和memoizedProps"></a><code>pendingProps</code> 和<code>memoizedProps</code></h3><p>从概念上讲,<code>props</code>是函数的参数。<code>Fiber</code>的<code>pendingProps</code>在其执行开始时设置,而<code>memoizedProps</code>在末尾设置。</p><p>当传入的<code>pendingProps</code>等于<code>memoizedProps</code>时,它表明<code>Fiber</code>以前的输出可以重复使用,从而防止不必要的工作。</p><h3 id="pendingProps的优先级"><a href="#pendingProps的优先级" class="headerlink" title="pendingProps的优先级"></a><code>pendingProps</code>的优先级</h3><p>指示由<code>Fiber</code>表示的 <code>props</code> 的优先级的数字。”React优先级（ReactPriorityLevel）”模块列出了不同的优先级及其表示的内容。</p><p>除 NoWork(0)外,数字越大表示优先级较低。例如,可以使用以下函数检查光纤的优先级是否至少与给定级别相同:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">matchesPriority</span>(<span class="params">fiber, priority</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fiber.pendingWorkPriority !== <span class="number">0</span> &amp;&amp;</span><br><span class="line">         fiber.pendingWorkPriority &lt;= priority</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此函数仅用于说明;它实际上不是 React Fiber 代码库的一部分。</p><p>协调程序（scheduler）使用优先级字段搜索要执行的下一个工作单元。</p><p>此算法将在以后的章节中讨论。</p><h3 id="alternate"><a href="#alternate" class="headerlink" title="alternate"></a>alternate</h3><h4 id="flush"><a href="#flush" class="headerlink" title="flush"></a><em>flush</em></h4><p>刷新（flush）Fiber 是将他的输出渲染在屏幕上。</p><h4 id="work-in-progress"><a href="#work-in-progress" class="headerlink" title="work-in-progress"></a><em>work-in-progress</em></h4><p>尚未完成的Fiber;从概念上讲,是尚未从堆栈框架返回的 <code>Fiber</code>。</p><p>在任何时候,组件实例最多具有两个与其对应的 <code>Fiber</code>: 当前的 Fiber <code>the current Fiber</code>、刷新的Fiber <code>flushed fiber</code> 和 尚未完成的Fiber <code>work-in-progress Fiber</code>。</p><p><code>the current Fiber</code>的备用是<code>work-in-progress Fiber</code>,而<code>work-in-progress Fiber</code>的备用是<code>the current Fiber</code>。</p><p>使用称为克隆Fiber <code>cloneFiber</code> 的功能 懒创建（ lazily using ） <code>Fiber</code>的备用<code>Fiber</code>。<code>cloneFiber</code> 将尝试重用 <code>Fiber</code> 的备用对象<code>work-in-progress Fiber</code>(如果存在)而不是始终创建新对象,从而最大限度地减少分配。</p><p>工程师们应该将 备用字段 <code>alternate</code> 作为实现 <code>Fiber</code>的细节,但它在代码库中经常弹出,因此在此处讨论它非常有价值。</p><h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><h4 id="host-component"><a href="#host-component" class="headerlink" title="host component"></a><em>host component</em></h4><p>React 应用程序的叶节点。它们特定地存在于渲染环境(例如,在浏览器应用中,它们是”div”,”span”等)。在 JSX 中,它们使用 <strong>小写的名称标签</strong> 表示。</p><p>从概念上讲,<code>Fiber</code>的输出是函数的返回值。</p><p>每个<code>Fiber</code>最终都有输出,但输出仅由<strong>host component</strong>在叶节点上创建，这个输出然后再向树上转移。</p><p>最终提供给渲染器的输出的内容将刷新渲染到展示的环境中。渲染器有责任定义这个最终输出的内容是应该 创建 还是 更新。</p><h1 id="未来部分"><a href="#未来部分" class="headerlink" title="未来部分"></a>未来部分</h1><p>这就是现在所有的一切,但本文档还远远不够完整。后续部分将介绍更新整个生命周期中使用的算法。要涵盖的主题包括:</p><ul><li>协调程序（scheduler）如何找到要执行的下一个工作单元。</li><li>如何通过 Fiber 树跟踪和传播优先级。</li><li>计划程序如何知道何时暂停和恢复工作。</li><li>如何刷新工作并标记为已完成。</li><li>副作用(如生命周期方法)的工作原理。</li><li>什么是协同例程,以及如何使用它来实现上下文和布局等功能。</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://github.com/acdlite/react-fiber-architecture">Fiber</a><br><a href="https://zh-hans.reactjs.org/docs/faq-internals.html#what-is-react-fiber">Virtual DOM 及内核</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GMTC大会记</title>
      <link href="/2019/06/27/GMTC%E5%A4%A7%E4%BC%9A%E8%AE%B0/"/>
      <url>/2019/06/27/GMTC%E5%A4%A7%E4%BC%9A%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="急速秒卡0-3s完成渲染"><a href="#急速秒卡0-3s完成渲染" class="headerlink" title="急速秒卡0.3s完成渲染"></a>急速秒卡0.3s完成渲染</h1><h2 id="闪开优化"><a href="#闪开优化" class="headerlink" title="闪开优化"></a>闪开优化</h2><p>Data PreFetch</p><h2 id="容器选择"><a href="#容器选择" class="headerlink" title="容器选择"></a>容器选择</h2><p>不用native，成本太高<br>Weex<br>H5 优化<br>PWA方向<br>SSR方向</p><h2 id="重新理解页面渲染"><a href="#重新理解页面渲染" class="headerlink" title="重新理解页面渲染"></a>重新理解页面渲染</h2><p>数据模板<br>最快的是从内存中直接取出模板并且渲染；</p><h2 id="NSR预渲染"><a href="#NSR预渲染" class="headerlink" title="NSR预渲染"></a>NSR预渲染</h2><p>Native Server Render</p><h2 id="移动端要求"><a href="#移动端要求" class="headerlink" title="移动端要求"></a>移动端要求</h2><h2 id="微服务化"><a href="#微服务化" class="headerlink" title="微服务化"></a>微服务化</h2><p>造轮子<br>首屏pureJSX + 非首屏Preact</p><h2 id="pureJsx"><a href="#pureJsx" class="headerlink" title="pureJsx"></a>pureJsx</h2><p>是一个没有Virtualdom的，但是最小组件还保留的React实现；<br>只有1KB；</p><hr><h1 id="Bilibili"><a href="#Bilibili" class="headerlink" title="Bilibili"></a>Bilibili</h1><p>网页最佳打开时间 不应超过2秒</p><p>上下游的维度来进行优化</p><h2 id="秒开"><a href="#秒开" class="headerlink" title="秒开"></a>秒开</h2><p>原来stage0：<br>loadHtml css loag-reporter jquery comment bundle bussiness video<br>优化stage0：<br>load HTML Base CSS video log-reporter</p><p>参考：（逐帧分析youtube）</p><p>原来Stage1:<br>palyer.js   init Player</p><p>优化Stage1:<br>vedio.js player.js =&gt; init player</p><p>原来Stage2:<br>Auth playUrl</p><p>优化Stage2:<br>HTML have playUrl ？playUrl(node ssr) : Auth playurl</p><p>ps: 充分利用nodessr</p><p>优化stage3:<br>避免使用第一个预检请求 + MSE（MediaSourceExtensions） 初始化与拉流并行</p><p>优化入口处理：<br>1、通过分析用户点击分析，推荐视频播放地址预取；<br>2、局部SPA；<br>3、入口部分预取播放器资源；<br>4、热门视频头部缓存预取（与页同时输出）</p><p>优化难点：<br>1、长尾优化（可能是CDN的问题）；</p><p>产品优化：<br>新版播放页：播放器上移，资源优先级高</p><p>视频类型：MPEG-DASH<br>这个牛逼⤴️</p><h2 id="弹幕体验"><a href="#弹幕体验" class="headerlink" title="弹幕体验"></a>弹幕体验</h2><p>基于RequestAnimationFrame</p><ul><li>css3（逐帧添加）</li><li>Canvas（逐帧绘制）</li></ul><p>弹幕碰撞检测，因为没有固定轨道，</p><p>优化点：复用弹幕节点，避免DOM频繁创建与移除</p><h3 id="蒙版弹幕"><a href="#蒙版弹幕" class="headerlink" title="蒙版弹幕"></a>蒙版弹幕</h3><p>基于css3 mask-image属性的弹幕，配合人工智能学习的路径点制造出防遮挡的效果</p><p>优化蒙版：</p><ol><li>自动降帧</li><li>大屏幕下没有办法</li></ol><hr><h1 id="基于dom的幻灯片实现"><a href="#基于dom的幻灯片实现" class="headerlink" title="基于dom的幻灯片实现"></a>基于dom的幻灯片实现</h1><ul><li>编辑器实现思路</li><li>编辑器的技术选型</li><li>编辑器的功能难点与解决方法</li></ul><p>实现思路不同于模块化、组件化，是 从点到线，从线到面</p><p>office open xml 基于xml格式的office文档标准（用来定义某些元素到底需要实现什么东西）</p><h2 id="选型考虑范围"><a href="#选型考虑范围" class="headerlink" title="选型考虑范围"></a>选型考虑范围</h2><ol><li>图形</li></ol><ul><li>svg 有性能问题（1000以上会出现卡顿），但是渲染能力强，在移动端显示正常</li><li>canvas 性能好，但是移动端（resize）的时候会出问题</li></ul><p>最后选了svg</p><ol start="2"><li>富文本<br>HTML DOM contenteditable<br>第三方编辑器： Draft.js(react) \ CKEditor \ Quill \ ProseMisrror</li></ol><ul><li>最大化利用浏览器</li><li>数据与UI分离</li><li>保证数据与DOM的一致性</li><li>可扩展</li></ul><h2 id="实时协作算法"><a href="#实时协作算法" class="headerlink" title="实时协作算法"></a>实时协作算法</h2><p>OT算法<br>用insert、remove和retain来表示文档内容及其修改</p><p>insert 插入<br>remove 移除<br>retain 保留</p><p>A用户 operate1 ⬇️ operate2’ -&gt;</p><p>B用户 operate2 ⤴️ operate1’ -&gt;</p><h2 id="图形变换移动"><a href="#图形变换移动" class="headerlink" title="图形变换移动"></a>图形变换移动</h2><ul><li>移动</li><li>缩放</li><li>旋转</li></ul><p>群体变换（多选中几个，做移动，做缩放，做旋转），如果固定坐标系，计算变更后的坐标，很麻烦，<br>因此，选择矩阵变换⬇️<br><strong>仿射变换</strong><br>P2(x’, y’) = T1 * T2 * T3 * P1(x, y)</p><hr><h1 id="数据可视化-React-amp-D3"><a href="#数据可视化-React-amp-D3" class="headerlink" title="数据可视化 React &amp; D3"></a>数据可视化 React &amp; D3</h1><p>数据可视化分析，从数据中提取信息，用交互式图表展示出来，从而做出操作；</p><p>应用场景；<br>事件序列数据，帮助产品经理决策；<br>机器学习模型数据，帮助机器学习工程师分析与检测模型的更迭；</p><h2 id="前端大数据可视化"><a href="#前端大数据可视化" class="headerlink" title="前端大数据可视化"></a>前端大数据可视化</h2><p>出现的情况：高apis请求等</p><ul><li>多样数据总结</li><li>多维度数据过滤</li><li>高频API请求</li><li>高度依赖 <strong>React+ Redux</strong></li><li><strong>Observable</strong> 管理协调数据</li></ul><h2 id="D3与数据可视化数据"><a href="#D3与数据可视化数据" class="headerlink" title="D3与数据可视化数据"></a>D3与数据可视化数据</h2><p>有任务 + data + 概念模型 =&gt; 处理（合理利用人类视觉原理图形化数据） =&gt; 生成D3图表</p><p>人类视觉 不同的图形类型来处理数据<br>视觉变量 selective</p><h3 id="D3核心概念"><a href="#D3核心概念" class="headerlink" title="D3核心概念"></a>D3核心概念</h3><p>数据驱动文档 =&gt; Data-Driven Documents<br>数据到Dom的映射</p><ul><li>数据与DOM元素绑定</li><li>使用函数绘制到svg上</li></ul><p>DOM 操作 - 与 React的异同<br>同： 数据与DOM一一对应<br>异：对于数据的变化直接掌控</p><h3 id="辅助数据加工-数组变形"><a href="#辅助数据加工-数组变形" class="headerlink" title="辅助数据加工 - 数组变形"></a>辅助数据加工 - 数组变形</h3><ul><li>统计数据 =&gt; 数据总结</li><li>数据变形 =&gt; 数据分面</li></ul><h3 id="辅助数据加工-比例尺"><a href="#辅助数据加工-比例尺" class="headerlink" title="辅助数据加工 - 比例尺"></a>辅助数据加工 - 比例尺</h3><p>主要是为了视觉元素支持</p><h3 id="辅助数据加工-布局计算"><a href="#辅助数据加工-布局计算" class="headerlink" title="辅助数据加工 - 布局计算"></a>辅助数据加工 - 布局计算</h3><h3 id="数据图像的映射-颜色操作"><a href="#数据图像的映射-颜色操作" class="headerlink" title="数据图像的映射 - 颜色操作"></a>数据图像的映射 - 颜色操作</h3><h3 id="数据图像的映射-路径生成"><a href="#数据图像的映射-路径生成" class="headerlink" title="数据图像的映射 - 路径生成"></a>数据图像的映射 - 路径生成</h3><p>选用内置插值方式将数据转化为路径<br>Gestalt law of continuity</p><h3 id="数据图像的映射-动画"><a href="#数据图像的映射-动画" class="headerlink" title="数据图像的映射 - 动画"></a>数据图像的映射 - 动画</h3><p>利用插值函数，一行代码实现动画效果</p><h2 id="D3可视化的优势"><a href="#D3可视化的优势" class="headerlink" title="D3可视化的优势"></a>D3可视化的优势</h2><ul><li>数据与图形元素的一一对应<ul><li>用户与图形元素的交互 =&gt; 数据的选取</li></ul></li><li>丰富的数据处理与图形映射功能<ul><li>辅助生成图形</li><li>高度自由化</li></ul></li></ul><h2 id="结合React"><a href="#结合React" class="headerlink" title="结合React"></a>结合React</h2><h3 id="D3的缺陷"><a href="#D3的缺陷" class="headerlink" title="D3的缺陷"></a>D3的缺陷</h3><ul><li>代码冗长<ul><li>Margin得放入函数计算</li></ul></li><li>实现响应式图表需要直接处理window resize</li><li>React与D3在DOM管理上存在潜在冲突</li></ul><h3 id="使用react-d3kit-实现D3代码复用"><a href="#使用react-d3kit-实现D3代码复用" class="headerlink" title="使用react-d3kit 实现D3代码复用"></a>使用react-d3kit 实现D3代码复用</h3><p>twitter团队搞得<br>d3kit：把D3代码封装成ES6</p><p>解决了margin枯燥的计算<br>解决了resize时候的问题</p><p>和react结合</p><ul><li>用react 的状态来控制图表的重新渲染</li><li>利用Redux来统筹不同可视化组件的设置</li><li>D3事件与react时间管理器的衔接</li></ul><hr><h1 id="前端极致优化"><a href="#前端极致优化" class="headerlink" title="前端极致优化"></a>前端极致优化</h1><p>选择性能优化工具<br>需要的能力（软实力-需求梳理、推广落地，硬实力-操作系统知识、数据处理能力、服务器知识、系统设计能力）</p><ul><li>理解优化的收益和所处阶段<br>4个阶段</li><li>性能优化的数据支撑平台<br>现状、目标、成果</li><li>极致技术细节</li></ul><p>ps:性能优化不是全部优化，在某些区间内优化</p><h1 id="内容优化"><a href="#内容优化" class="headerlink" title="内容优化"></a>内容优化</h1><ol><li>文本图片</li></ol><p>文本压缩、图片压缩<br>（gzip、foundation）</p><p>图片 （svg =&gt; 可以gzip压缩）（无损压缩，压缩的是图片信息）（抽离像素通道）（图片转换成样式表）</p>]]></content>
      
      
      
        <tags>
            
            <tag> 前端大会 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React虚拟DOM 深入学习</title>
      <link href="/2019/05/01/React-virtual-dom/"/>
      <url>/2019/05/01/React-virtual-dom/</url>
      
        <content type="html"><![CDATA[<h1 id="为什么我需要（React-virtual-dom）？"><a href="#为什么我需要（React-virtual-dom）？" class="headerlink" title="为什么我需要（React-virtual-dom）？"></a>为什么我需要（React-virtual-dom）？</h1><p>产品的功能源自需求，react 作为一个成功的UI库也是如此。</p><p>假象我们有这种需求：</p><blockquote><p>我需要自己撸一个轮子，能够在数据改变的时候，及时相应在页面上面，怎么做？</p></blockquote><p>一个工作两年左右的工程师就会思考：</p><ol><li>state改变监听</li><li>拥有一个JSX模板</li><li>state改变被监听+模板变化 = 生成一个DOM展示；</li><li>state又变了；</li><li>state改变被监听+模板变化 = 生成一个新的DOM展示；</li></ol><p>问题存在吗？</p><p>问题很大：</p><ul><li>第一次生成了一整个DOM；</li><li>第二次有生成了一整个DOM;</li><li>第二次的DOM完整替换了第一次生成的DOM;</li></ul><p>重绘很耗费性能的好嘛。</p><p>粗略地改进：<br>…4</p><ol start="5"><li>在替换旧的DOM之前进行对比，不一样的再替换之（实际上就是DocumentFragment）;</li><li>展示新的DOM;</li></ol><p>提升如何？<br>其实并不明显</p><p>React方案改进<br>…2</p><ol start="3"><li>state改变被监听+模板变化 =&gt; 生成虚拟DOM，用以描述真实DOM；</li><li>用虚拟DOM生成真实DOM；</li><li>state又变了；</li><li>state改变被监听+模板变化 =&gt; 生成新的虚拟DOM，比较旧的虚拟DOM和新鲜的虚拟DOM，找到区别，直接修改；</li></ol><p>终于：</p><ul><li>性能提升一截；</li><li>甚至使得跨端应用成为现实，RN（React Native）得到广泛使用。为什么呢？因为原生应用里不存在DOM这个概念，<br>但是虚拟DOM这个思想，这个简单的js对象是完全可以正常跑通的，因此，只需要在执行环境中判断出是在Browser还是App中，就可以使React开发多端应用。</li></ul><h1 id="都9102年了，你凭什么还说我们浏览器慢？"><a href="#都9102年了，你凭什么还说我们浏览器慢？" class="headerlink" title="都9102年了，你凭什么还说我们浏览器慢？"></a>都9102年了，你凭什么还说我们浏览器慢？</h1><p>先来看一看浏览器加载HTML文件都需要做什么：<br><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4evhx81ttj30ho089dgf.jpg" alt="BrowserPaint"></p><p>虽然每个浏览器有自己的引擎，但是大致工作流程都差不多，如图所示分为5步：</p><ol><li>用HTML分析器（解析器），分析HTML元素，构建一棵<strong>DOM 树</strong>；</li><li>用CSS分析器（解析器），分析CSS文件和元素的inline样式，生成<strong>页面样式表</strong>；</li><li>将前面的<strong>DOM树</strong>和<strong>样式表</strong>结合，构建一棵<strong>Render树</strong>。这个过程被称为Attachment，每一个DOM节点都拥有attach方法，接收样式信息，返回一个render对象（renderer)。通过这些render对象(renderer)构成一棵<strong>Render树</strong>；</li><li>浏览器对着<strong>Render树</strong>开始布局，为每一个存在于Render树上的节点确定一个精确的坐标；</li><li>Render树有了，节点显示的位置坐标也有了，最后一步就是调用每个节点的<strong>paint</strong>方法，让他们现出原形！</li></ol><p>那么，当你在撸代码的时候，使用了原生的api，或者是JQuery（老夫不管……）去操作DOM时，浏览器就会按照以上5个步骤重新走一遍，而且更加恐怖的是，假设你在写代码时，“我要一次性更新10个DOM节点”，那在浏览器眼中，它收到第一个更新请求后并不知道后面还有九个，因此立刻执行（1.2.3.4.5.），最终执行了10遍流程。<br>假如说每一次新的更新都会对前一个DOM节点的坐标值发生影响，那么也就是说，只有最后一次计算节点的坐标才是有用的，前面9次白算！<br>所以说，虽然随着时代的变迁，计算机硬件不停地升级，Mac电脑都卖到2W了，但是操作DOM的代价依然非常昂贵，频繁地操作更会出现卡顿等奇奇怪怪の现象，严重影响用户体验。<br>不要反驳说，我一个小小的简单的DOM节点能有多少玩意儿啊？<br>给你看看<br><img src="http://ww2.sinaimg.cn/large/006tNc79ly1g4ew0zde6ej32740jganl.jpg" alt=""></p><p>那怕是一个小小的div，都有如此多的属性，那么整个DOM树有多少，想想都害怕。</p><h1 id="什么是虚拟Dom呢？"><a href="#什么是虚拟Dom呢？" class="headerlink" title="什么是虚拟Dom呢？"></a>什么是虚拟Dom呢？</h1><p>虚拟DOM是一个描述真实DOM的简单js对象</p><p>回到上面那个问题中，加入一次操作中有10个更新DOM的操作，那么我虚拟DOM不会像普通浏览器那样傻傻的立即操作，而是将10次更新内容的diff保存到本地的一个js对象中，最终将这个js对象一次性attach到DOM树上，通知浏览器，你好去paint了，这样就可以极大程度上节约计算成本，避免无谓的计算，好钢要用在刀刃上。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VirtualDomTree = Element(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;virtual-container&#x27;</span> &#125;, [</span><br><span class="line">    Element(<span class="string">&#x27;p&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;Virtual DOM&#x27;</span>]),</span><br><span class="line">    Element(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;before update&#x27;</span>]),</span><br><span class="line">    Element(<span class="string">&#x27;ul&#x27;</span>, &#123;&#125;, [</span><br><span class="line">        Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;list-item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">        Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;list-item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>]),</span><br><span class="line">        Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;list-item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>]),</span><br><span class="line">    ])</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>好处很明显，数据的更新第一步反映在<strong>js对象</strong>上，在内存中对<strong>js对象</strong>的操作速度肯定比浏览器慢悠悠跑来的快得多，等到更新完毕，再交由浏览器去绘制，完美。</p><p>那再具体一点，到底是怎么实现的呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>tagName 节点名</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>props 节点的属性</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param </span>children 子节点</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span>(<span class="params">tagName, props, children</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Element)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Element(tagName, props, children);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.tagName = tagName;</span><br><span class="line">    <span class="built_in">this</span>.props = props || &#123;&#125;;</span><br><span class="line">    <span class="built_in">this</span>.children = children || [];</span><br><span class="line">    <span class="built_in">this</span>.key = props ? props.key : <span class="literal">undefined</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">this</span>.children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (child <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">            count += child.count;</span><br><span class="line">        &#125;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="built_in">this</span>.count = count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>除了以上三个参数之外还会保存key和count</p></blockquote><p>OK，到了这一步还没有结束，等到有了js对象之后，还需要将其映射成为真实的DOM：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.render = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="built_in">this</span>.tagName);</span><br><span class="line">    <span class="keyword">const</span> props = <span class="built_in">this</span>.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> props) &#123;</span><br><span class="line">        setAttr(el, propName, props[propName]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">this</span>.children.forEach(<span class="function">(<span class="params">child</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> childEl = (child <span class="keyword">instanceof</span> Element) ?</span><br><span class="line">                        child.render() : <span class="built_in">document</span>.createTextNode(child);</span><br><span class="line">        el.appendChild(childEl);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> el;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据DOM名调用源生的createElement创建真实DOM，将DOM的属性全都加到这个DOM元素上，如果有子元素继续递归调用创建子元素，并appendChild挂到该DOM元素上。这样就完成了从创建虚拟DOM到将其映射成真实DOM的全部工作。</p><h1 id="神秘的Diff算法"><a href="#神秘的Diff算法" class="headerlink" title="神秘的Diff算法"></a>神秘的Diff算法</h1><p>这个玩意儿算是面试总会问到的。</p><p>两棵树如果进行完全的比较，那么时间复杂度是O(n^3 );<br>但是通过《深入浅出React和Redux》这本书的介绍，Diff算法的时间复杂度只有O(n)！</p><p>要实现如此低的时间复杂度，那么就要牺牲一些东西，比如，深度遍历、精确性。<br>但是，在现实的前端开发中，跨层级的DOM元素的操作不是占据大多数情形的，因此，这么选择的Diff算法是最优的。</p><p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1g4eyqxkkccj31g00gmwh0.jpg" alt=""></p><p>diff算法中只会比较同层级的元素，一旦发现某一级之间有所不同，则会弃置其子级，直接用从新的差异的一级以及其下的所有子级替换旧的。我们会有个疑问，这样做那子级中相同的元素不是无法复用了吗，那怎么还能提高比对性能？这无疑是一种缺陷，但也带来了好处就是算法实现简单，也就提高了比对速度，因此最后也是能够提升性能的。</p><p>现在，某张小熠又新创建了一棵树，用于和上文中的树比较：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> newVirtualDomTree = Element(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;virtual-container&#x27;</span> &#125;, [</span><br><span class="line">    Element(<span class="string">&#x27;h3&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;Virtual DOM&#x27;</span>]),                     <span class="comment">// REPLACE</span></span><br><span class="line">    Element(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;after update&#x27;</span>]),                   <span class="comment">// TEXT</span></span><br><span class="line">    Element(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;newList&#x27;</span> &#125;, [              <span class="comment">// PROPS</span></span><br><span class="line">        Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">        <span class="comment">// Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 2&#x27;]),    // REORDER remove</span></span><br><span class="line">        Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>]),</span><br><span class="line">    ]),</span><br><span class="line">]);</span><br></pre></td></tr></table></figure><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4ez87s2x1j30z409i75b.jpg" alt=""><br>花里胡哨的线，但是也大概表达了Diff了些什么：</p><ul><li>第一种（蓝色）是最简单的，如图中的p标签变成了H3标签，这个过程被称之为 <strong><em><em>REPLACE</em></em></strong> 旧节点包括下面的子节点都将被卸载，如果新节点和旧节点仅仅是类型不同，但下面的所有子节点都一样时，这样做显得效率不高。但为了避免O(n^3 )的时间复杂度，这样做是值得的。这也提醒了React开发者，应该避免无谓的节点类型的变化，例如运行时将div变成p就没什么太大意义。</li><li>第二种（紫色）也比较简单，节点类型一样，仅仅属性或属性值变了。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">renderA: &lt;ul&gt;</span><br><span class="line">renderB: <span class="xml"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class:</span> &#x27;<span class="attr">newList</span>&#x27;&gt;</span></span></span><br><span class="line"><span class="xml">=&gt; [addAttribute class &quot;newList&quot;]</span></span><br></pre></td></tr></table></figure><p>这个过程被称为 <strong><em><em>PROPS</em></em></strong><br>这个时候不会触发节点的卸载（componentWillUnmounted）和装载（componentWillMount）生命周期，而是执行了 <strong>节点更新</strong> （shouldComponentUpdated =&gt; componentDidUpdated 系列方法）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span>(<span class="params">oldNode, newNode</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> oldProps = oldNode.props;</span><br><span class="line">    <span class="keyword">const</span> newProps = newNode.props;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> key;</span><br><span class="line">    <span class="keyword">const</span> propsPatches = &#123;&#125;;</span><br><span class="line">    <span class="keyword">let</span> isSame = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find out different props</span></span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (newProps[key] !== oldProps[key]) &#123;</span><br><span class="line">            isSame = <span class="literal">false</span>;</span><br><span class="line">            propsPatches[key] = newProps[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// find out new props</span></span><br><span class="line">    <span class="keyword">for</span> (key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!oldProps.hasOwnProperty(key)) &#123;</span><br><span class="line">            isSame = <span class="literal">false</span>;</span><br><span class="line">            propsPatches[key] = newProps[key];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> isSame ? <span class="literal">null</span> : propsPatches;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>第三种（绿色）就只是文本变化了，文本其实也是一个Text Node，这个简单，直接修改文字内容即可，被称之为 <strong><em><em>TEXT</em></em></strong></li><li>第四种是 移动、增加、删除子节点，这个过程被称之为 <strong><em><em>REORDER</em></em></strong></li></ul><p>具体可以看 <a href="https://www.infoq.cn/article/react-dom-diff/">虚拟DOM 算法解析</a></p><h2 id="列表渲染的元素，你如果不加key，我就嗷嗷叫……"><a href="#列表渲染的元素，你如果不加key，我就嗷嗷叫……" class="headerlink" title="列表渲染的元素，你如果不加key，我就嗷嗷叫……"></a>列表渲染的元素，你如果不加key，我就嗷嗷叫……</h2><p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1g4ezut9k77j310a02uwfs.jpg" alt=""><br>这个warning，vue和react都会报。他们强烈建议开发者，拜托你在写通过数组循环渲染item的时候，一定要加上key，不然我们在虚拟DOM比较的时候就只能进行两层循环，才知道什么发生改变了，你们开发者如果加上了key，那我们就可以非常快速且清晰地比较出新增和删除了什么东西！</p><p>比如⤵️</p><p>A B 【F】 C D E</p><p>我想要插入一个F元素，那么简单粗暴的方法就出现了：<br>卸载C，装载F，卸载D，装载C，卸载E，装载D，装载E<br><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4f02dkxxcj30su09w757.jpg" alt=""></p><p>如果我们在JSX里为数组或枚举型元素增加上key后，React就能根据key，直接找到具体的位置进行操作，效率比较高。</p><blockquote><p> Keys should be “stable, predictable, and unique.” 所以不建议在使用key的时候，简单地使用上数组的index属性，那个玩意儿会带来巨大的坑。</p></blockquote><p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1g4f08h182lj30s609ejsa.jpg" alt=""></p><blockquote><p>因此就变成了最小编辑距离问题，可以用Levenshtein Distance算法来实现，时间复杂度是O(M*N)，但通常我们只要一些简单的移动就能满足需要，降低点精确性，将时间复杂度降低到O(max(M, N)即可。</p></blockquote><p>最终Diff出来的结果</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="number">1</span>: [ &#123;<span class="attr">type</span>: REPLACE, <span class="attr">node</span>: Element&#125; ],</span><br><span class="line">    <span class="number">4</span>: [ &#123;<span class="attr">type</span>: TEXT, <span class="attr">content</span>: <span class="string">&quot;after update&quot;</span>&#125; ],</span><br><span class="line">    <span class="number">5</span>: [ &#123;<span class="attr">type</span>: PROPS, <span class="attr">props</span>: &#123;<span class="attr">class</span>: <span class="string">&quot;newList&quot;</span>&#125;&#125;, &#123;<span class="attr">type</span>: REORDER, <span class="attr">moves</span>: [&#123;<span class="attr">index</span>: <span class="number">2</span>, <span class="attr">type</span>: <span class="number">0</span>&#125;]&#125; ],</span><br><span class="line">    <span class="number">6</span>: [ &#123;<span class="attr">type</span>: REORDER, <span class="attr">moves</span>: [&#123;<span class="attr">index</span>: <span class="number">2</span>, <span class="attr">type</span>: <span class="number">0</span>&#125;]&#125; ],</span><br><span class="line">    <span class="number">8</span>: [ &#123;<span class="attr">type</span>: REORDER, <span class="attr">moves</span>: [&#123;<span class="attr">index</span>: <span class="number">2</span>, <span class="attr">type</span>: <span class="number">0</span>&#125;]&#125; ],</span><br><span class="line">    <span class="number">9</span>: [ &#123;<span class="attr">type</span>: TEXT, <span class="attr">content</span>: <span class="string">&quot;Item 3&quot;</span>&#125; ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最终映射到真实DOM中"><a href="#最终映射到真实DOM中" class="headerlink" title="最终映射到真实DOM中"></a>最终映射到真实DOM中</h2><p>深度遍历DOM将Diff的内容更新进去：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfsWalk</span>(<span class="params">node, walker, patches</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> currentPatches = patches[walker.index];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> len = node.childNodes ? node.childNodes.length : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        walker.index++;</span><br><span class="line">        dfsWalk(node.childNodes[i], walker, patches);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (currentPatches) &#123;</span><br><span class="line">        applyPatches(node, currentPatches);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的更新代码如下<br>其实就是根据Diff信息调用源生API操作DOM：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">applyPatches</span>(<span class="params">node, currentPatches</span>) </span>&#123;</span><br><span class="line">    currentPatches.forEach(<span class="function">(<span class="params">currentPatch</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (currentPatch.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> REPLACE: &#123;</span><br><span class="line">                <span class="keyword">const</span> newNode = (<span class="keyword">typeof</span> currentPatch.node === <span class="string">&#x27;string&#x27;</span>)</span><br><span class="line">                    ? <span class="built_in">document</span>.createTextNode(currentPatch.node)</span><br><span class="line">                    : currentPatch.node.render();</span><br><span class="line">                node.parentNode.replaceChild(newNode, node);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> REORDER:</span><br><span class="line">                reorderChildren(node, currentPatch.moves);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> PROPS:</span><br><span class="line">                setProps(node, currentPatch.props);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> TEXT:</span><br><span class="line">                <span class="keyword">if</span> (node.textContent) &#123;</span><br><span class="line">                    node.textContent = currentPatch.content;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// ie</span></span><br><span class="line">                    node.nodeValue = currentPatch.content;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">`Unknown patch type <span class="subst">$&#123;currentPatch.type&#125;</span>`</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候呼应开头了，虚拟DOM的目的是将所有操作累加起来，统计计算出所有的变化后，统一更新一次DOM，以上大概就是全部解析内容了。</p><h1 id="React-Fiber"><a href="#React-Fiber" class="headerlink" title="React Fiber"></a>React Fiber</h1><p>请看下一篇我的博客《React-Fiber学习笔记》</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p><a href="https://reactjs.org/docs/faq-internals.html#what-is-the-virtual-dom">What is the Virtual DOM?「React官网」</a><br><a href="https://www.infoq.cn/article/react-dom-diff/">深入浅出React： 虚拟DOM Diff 算法解析</a><br>链接挂掉了几个<br>深度剖析：如何实现一个 Virtual DOM 算法</p>]]></content>
      
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微信小程序开发指南</title>
      <link href="/2019/04/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/"/>
      <url>/2019/04/08/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><h2 id="小程序是什么"><a href="#小程序是什么" class="headerlink" title="小程序是什么"></a>小程序是什么</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小程序是一种全新的连接用户与服务的方式，它可以在微信内被便捷地获取和传播，同时具有出色的使用体验。</p><h2 id="发展史"><a href="#发展史" class="headerlink" title="发展史"></a>发展史</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小程序并非凭空冒出来的一个概念。当微信中的 WebView 逐渐成为移动 Web 的一个重要入口时，微信就有相关的 JS API 了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">WeixinJSBridge.invoke(<span class="string">&#x27;imagePreview&#x27;</span>, &#123;</span><br><span class="line">    current: <span class="string">&#x27;http://inews.gtimg.com/newsapp_bt/0/1693121381/641&#x27;</span>,</span><br><span class="line">    urls: [ <span class="comment">// 所有图片的URL列表，数组格式</span></span><br><span class="line">        <span class="string">&#x27;https://img1.gtimg.com/10/1048/104857/10485731_980x1200_0.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://img1.gtimg.com/10/1048/104857/10485726_980x1200_0.jpg&#x27;</span>,</span><br><span class="line">        <span class="string">&#x27;https://img1.gtimg.com/10/1048/104857/10485729_980x1200_0.jpg&#x27;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> (<span class="params">res</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res.err_msg)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以上是一个调用微信原生组件浏览图片的JS API，相比于额外引入一个JS图片预览组件库，这种调用方式显得非常简洁和高效。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;实际上，微信官方是没有对外暴露过如此调用的，此类 API 最初是提供给腾讯内部一些业务使用，很多外部开发者发现了之后，依葫芦画瓢地使用了，逐渐成为微信中网页的事实标准。2015年初，微信发布了一整套网页开发工具包，称之为 JS-SDK，开放了拍摄、录音、语音识别、二维码、地图、支付、分享、卡券等几十个API。给所有的 Web 开发者打开了一扇全新的窗户，让所有开发者都可以使用到微信的原生能力，去完成一些之前做不到或者难以做到的事情。</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;使用 JS-SDK 调用图片预览组件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">wx.previewImage(&#123;</span><br><span class="line">current: <span class="string">&#x27;https://img1.gtimg.com/10/1048/104857/10485726_980x1200_0.jpg&#x27;</span>,</span><br><span class="line">urls: [ <span class="comment">// 所有图片的URL列表，数组格式</span></span><br><span class="line">    <span class="string">&#x27;https://img1.gtimg.com/10/1048/104857/10485731_980x1200_0.jpg&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://img1.gtimg.com/10/1048/104857/10485726_980x1200_0.jpg&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;https://img1.gtimg.com/10/1048/104857/10485729_980x1200_0.jpg&#x27;</span></span><br><span class="line">],</span><br><span class="line"><span class="function"><span class="title">success</span>(<span class="params">res</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>JS-SDK 解决了移动网页能力不足的问题，通过暴露微信的接口使得 Web 开发者能够拥有更多的能力，然而在更多的能力之外，JS-SDK 的模式并没有解决使用移动网页遇到的体验不良的问题。用户在访问网页的时候，在浏览器开始显示之前都会有一个的白屏过程，在移动端，受限于设备性能和网络速度，白屏会更加明显。微信官方把很多技术精力放置在如何帮助平台上的Web开发者解决这个问题。因此微信官方设计了一个 JS-SDK 的增强版本，其中有一个重要的功能，称之为“微信 Web 资源离线存储”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">微信 Web 资源离线存储是面向 Web 开发者提供的基于微信内的 Web 加速方案。</span><br><span class="line">通过使用微信离线存储，Web 开发者可借助微信提供的资源存储能力，直接从微信本地加载 Web 资源而不需要再从服务端拉取，从而减少网页加载时间，为微信用户提供更优质的网页浏览体验。每个公众号下所有 Web App 累计最多可缓存 5M 的资源。</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;然而，页面切换的生硬和点击的迟滞感还是会给开发者带来不好的体验，微信官方希望能够给出：</p><ul><li>快速的加载</li><li>更强大的能力</li><li>原生的体验</li><li>易用且安全的微信数据开放</li><li>高效和简单的开发<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因此，微信小程序就诞生了。</li></ul><h2 id="小程序与普通网页开发的区别"><a href="#小程序与普通网页开发的区别" class="headerlink" title="小程序与普通网页开发的区别"></a>小程序与普通网页开发的区别</h2><p>相似点：主要开发语言是 JavaScript；</p><p>不同点：</p><p>小程序的网页开发渲染线程和脚本线程是双线程分离的，逻辑层运行在 JSCore 中，并没有一个完整浏览器对象，因而缺少相关的DOM API和BOM API。这一区别导致了前端开发非常熟悉的一些库，例如 jQuery、 Zepto 等，在小程序中是无法运行的。同时 JSCore 的环境同 NodeJS 环境也是不尽相同，所以一些 NPM 的包在小程序中也是无法运行的。<br>双线程</p><p>网页开发面临各式各样的浏览器，PC 端需要面对 IE、Chrome、QQ浏览器等，在移动端需要面对Safari、Chrome以及 iOS、Android 系统中的各式 WebView ，小程序面临的是两大操作系统 iOS 和 Android 的微信客户端，以及用于辅助开发的小程序开发者工具。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在开发的过程中会经常发现，为什么我在（开发工具上）是好的，在我的（安卓手机）上也是好的，到你的（苹果手机）上就不好使了呢？<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;因为，三个开发环境也是有很大差异的。</p><table><thead><tr><th>运行环境</th><th>逻辑层</th><th>渲染层</th></tr></thead><tbody><tr><td>iOS</td><td>JavaScriptCore</td><td>WKWebView</td></tr><tr><td>安卓</td><td>V8</td><td>chromium定制内核</td></tr><tr><td>小程序开发者工具</td><td>NWJS</td><td>Chrome WebView</td></tr></tbody></table><p>开发流程，网页开发者在开发网页的时候，只需要使用到浏览器，并且搭配上一些辅助工具或者编辑器即可。小程序的开发则有所不同，需要经过申请小程序帐号、安装小程序开发者工具、配置项目等等过程方可完成。</p><h1 id="小程序技术选型"><a href="#小程序技术选型" class="headerlink" title="小程序技术选型"></a>小程序技术选型</h1><h2 id="渲染技术"><a href="#渲染技术" class="headerlink" title="渲染技术"></a>渲染技术</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;现在通用的渲染技术有：web渲染、Native渲染、web与Native混合渲染也就是Hybrid渲染。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小程序选择了 Hybrid 的渲染方式，可以用一种近似 Web 的方式来开发，并且还可以实现在线更新代码。同时，引入原生组件有以下好处：</p><p>扩展 Web 的能力。比如像输入框组件（input, textarea）有更好地控制键盘的能力<br>体验更好，同时也减轻 WebView 的渲染工作<br>绕过 setData、数据通信和重渲染流程，使渲染性能更好</p><h2 id="基础库"><a href="#基础库" class="headerlink" title="基础库"></a>基础库</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小程序的基础库是 JavaScript 编写的，它可以被注入到渲染层和逻辑层运行。主要用于：</p><p>在渲染层，提供各类组件来组建界面的元素<br>在逻辑层，提供各类 API 来处理各种逻辑<br>处理数据绑定、组件系统、事件系统、通信系统等一系列框架逻辑<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于小程序的渲染层和逻辑层是两个线程管理，两个线程各自注入了基础库。小程序的基础库不会被打包在某个小程序的代码包里边，它会被提前内置在微信客户端。这样可以：</p><p>降低业务小程序的代码包大小<br>可以单独修复基础库中的 Bug，无需修改到业务小程序的代码包</p><h2 id="Exparser-框架"><a href="#Exparser-框架" class="headerlink" title="Exparser 框架"></a>Exparser 框架</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Exparser 是微信小程序的组件组织框架，内置在小程序基础库中，为小程序的各种组件提供基础的支持。小程序内的所有组件，包括内置组件和自定义组件，都由 Exparser 组织管理。Exparser 特点包括：</p><p>基于 Shadow DOM 模型：模型上与 WebComponents 的 ShadowDOM 高度相似，但不依赖浏览器的原生支持，也没有其他依赖库；实现时，还针对性地增加了其他 API 以支持小程序组件编程。<br>可在纯 JS 环境中运行：这意味着逻辑层也具有一定的组件树组织能力。<br>高效轻量：性能表现好，在组件实例极多的环境下表现尤其优异，同时代码尺寸也较小。</p><h1 id="小程序基础"><a href="#小程序基础" class="headerlink" title="小程序基础"></a>小程序基础</h1><p>目录结构</p><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上图为微信小程序的项目结构，pages下面包含了小程序中的每一个页面，每一个页面由页面结构，页面样式，页面配置和逻辑代码四部分组成。</p><ul><li>页面结构<br>页面结构文件为index.wxml，通过微信自定义的标签来写。</li><li>页面逻辑<br>页面逻辑通过JavaScript来书写。</li><li>页面样式表<br>类似CSS文件，来定义页面内元素的样式。</li><li>页面配置<br>页面内的权限等配置信息。</li></ul><h2 id="程序与页面"><a href="#程序与页面" class="headerlink" title="程序与页面"></a>程序与页面</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当小程序准备加载的时候，微信会把整个小程序的代码包下载到本地。<br>紧接着通过 app.json 的 pages 字段就可以知道你当前小程序的所有页面路径:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="string">&quot;pages&quot;</span>: [</span><br><span class="line">        <span class="string">&quot;pages/index/index&quot;</span>,</span><br><span class="line">        <span class="string">&quot;pages/logs/logs&quot;</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;这个配置说明在 当前项目定义了两个页面，分别位于 pages/index/index 和 pages/logs/logs。而写在 pages 字段的第一个页面就是这个小程序的首页（打开小程序看到的第一个页面）。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;再接着，微信客户端就把首页的代码装载进来，通过小程序底层的一些机制，就可以渲染出这个首页。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小程序启动之后，在 app.js 定义的 App 实例的 onLaunch 回调会被执行:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">App(&#123;</span><br><span class="line">    <span class="function"><span class="title">onLaunch</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 小程序启动之后 触发</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">onShow</span>(<span class="params">options</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 页面出现的时候触发</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">onHide</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 页面隐藏的时候触发.</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">onError</span>(<span class="params">msg</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 页面出错的时候触发</span></span><br><span class="line">    &#125;,</span><br><span class="line">    globalData: <span class="string">&#x27;这是全局的数据&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;整个小程序只有一个 App 实例，是全部页面共享的。开发者可以通过 getApp 方法获取到全局唯一的 App 示例，获取App上的数据或调用开发者注册在 App 上的函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// logs.js</span></span><br><span class="line"><span class="keyword">const</span> appInstance = getApp()</span><br><span class="line"><span class="built_in">console</span>.log(appInstance.globalData) <span class="comment">// 这是全局的数据</span></span><br></pre></td></tr></table></figure><h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>基础组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span>&gt;</span><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原生组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><p>自定义组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-component</span>&gt;</span><span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;微信官方提供了大量的 小程序的API 供开发者使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 微信扫一扫</span></span><br><span class="line">wx.scanCode(&#123;</span><br><span class="line">success: <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="小程序发布"><a href="#小程序发布" class="headerlink" title="小程序发布"></a>小程序发布</h1><h2 id="小程序发布多态"><a href="#小程序发布多态" class="headerlink" title="小程序发布多态"></a>小程序发布多态</h2><table><thead><tr><th>权限</th><th>说明</th></tr></thead><tbody><tr><td>开发版本</td><td>使用开发者工具，可将代码上传到开发版本中。 开发版本只保留每人最新的一份上传的代码。 点击提交审核，可将代码提交审核。开发版本可删除，不影响线上版本和审核中版本的代码。</td></tr><tr><td>体验版本</td><td>可以选择某个开发版本作为体验版，并且选取一份体验版。</td></tr><tr><td>审核中版本</td><td>只能有一份代码处于审核中。有审核结果后可以发布到线上，也可直接重新提交审核，覆盖原审核版本。</td></tr><tr><td>线上版本</td><td>线上所有用户使用的代码版本，该版本代码在新版本代码发布后被覆盖更新。</td></tr></tbody></table><h2 id="小程序发布过程"><a href="#小程序发布过程" class="headerlink" title="小程序发布过程"></a>小程序发布过程</h2><p>简而言之：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a.预览 --&gt; b.上传代码 --&gt; c.提交审核 --&gt; d.发布</span><br><span class="line"># （开发者工具a.b.）</span><br><span class="line">#（后台c.d.）</span><br></pre></td></tr></table></figure><p><a href="发布文档">https://developers.weixin.qq.com/miniprogram/dev/framework/quickstart/release.html#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%89%88%E6%9C%AC</a></p><h1 id="小程序WXML的一些姿势"><a href="#小程序WXML的一些姿势" class="headerlink" title="小程序WXML的一些姿势"></a>小程序WXML的一些姿势</h1><h2 id="姿势们"><a href="#姿势们" class="headerlink" title="姿势们"></a>姿势们</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 简单用法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>hello world!<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 变量绑定 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; variable &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 动态渲染 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span>&gt;</span>&#123;&#123; areUOk ? &#x27;fine&#x27; : &#x27;bad&#x27; &#125;&#125;<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 条件渲染 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:if</span>=<span class="string">&quot;&#123;&#123; people &gt; 6 &#125;&#125;&quot;</span>&gt;</span>拍皮球<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:elif</span>=<span class="string">&quot;&#123;&#123; 2 &lt; people &lt; 6 &#125;&#125;&quot;</span>&gt;</span>撸串<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:else</span>&gt;</span>加班<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 列表渲染 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">view</span> <span class="attr">wx:for</span>=<span class="string">&quot;&#123;&#123; list &#125;&#125;&quot;</span>&gt;</span>...<span class="tag">&lt;/<span class="name">view</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">name</span>=<span class="string">&quot;muban&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>引入<br>import<br>include 两种方法<br>！！！此处有大坑，import方法不具备递归功能， A import B ，B 中 import C，但是A就无法使用C辽！！！</p></blockquote><h2 id="属性们"><a href="#属性们" class="headerlink" title="属性们"></a>属性们</h2><table><thead><tr><th>属性名</th><th>类型</th><th>描述</th><th>注解</th></tr></thead><tbody><tr><td>id</td><td>String</td><td>组件的唯一标识</td><td>整个页面唯一</td></tr><tr><td>class</td><td>String</td><td>组件的样式类</td><td>在对应的 WXSS 中定义的样式类</td></tr><tr><td>style</td><td>String</td><td>组件的内联样式</td><td>可以动态设置的内联样式</td></tr><tr><td>hidden</td><td>Boolean</td><td>组件是否显示</td><td>所有组件默认显示</td></tr><tr><td>data-*</td><td>Any</td><td>自定义属性</td><td>组件上触发的事件时，会发送给事件处理函数</td></tr><tr><td>bind/catch</td><td>EventHandler</td><td>组件的事件</td><td>bind冒泡，catch不冒泡</td></tr></tbody></table><h1 id="小程序wxss的一些姿势"><a href="#小程序wxss的一些姿势" class="headerlink" title="小程序wxss的一些姿势"></a>小程序wxss的一些姿势</h1><h2 id="特殊的单位-rpx-（responsive-pixel）"><a href="#特殊的单位-rpx-（responsive-pixel）" class="headerlink" title="特殊的单位 rpx （responsive pixel）"></a>特殊的单位 rpx （responsive pixel）</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;目的是更多型号的手机屏幕可以展示差不多的样式，如果用了px，就可能在大屏幕下过多留白，小屏幕下过于拥挤。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;小程序编译后，rpx会做一次px换算。换算是以375个物理像素为基准，也就是在一个宽度为375物理像素的屏幕下，1rpx = 1px。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;举个栗子：iphone6是375px宽度，也就是750物理像素，这个时候对应的rpx就是<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1rpx = 375 / 750 = 0.5px</p><h2 id="微信rpx"><a href="#微信rpx" class="headerlink" title="微信rpx"></a>微信rpx</h2><h2 id="使用wxss"><a href="#使用wxss" class="headerlink" title="使用wxss"></a>使用wxss</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;常规：按照上面目录结构当中的方式，是无需重复引用style文件的，直接定义直接用；<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;骚操作：在wxss文件中使用@import</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.wxss</span></span><br><span class="line">@<span class="keyword">import</span> url(<span class="string">&#x27;./logs.wxss&#x27;</span>)</span><br></pre></td></tr></table></figure><p>内联样式：不用多说的</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">style</span>=<span class="string">&quot;&#123;&#123; font-size: 24rpx; &#125;&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="小程序Js的一些姿势"><a href="#小程序Js的一些姿势" class="headerlink" title="小程序Js的一些姿势"></a>小程序Js的一些姿势</h1><h2 id="闲话"><a href="#闲话" class="headerlink" title="闲话"></a>闲话</h2><p>可能在很多开发者的眼中，JavaScript 和 ECMAScript 是等价的，然而，其实这两者还是有很大不同的：<br>JavaScript是ECMAScript的实现形式。</p><h3 id="在浏览器中"><a href="#在浏览器中" class="headerlink" title="在浏览器中"></a>在浏览器中</h3><table><thead><tr><th>浏览器中的JavaScript</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td>ECMAScript</td><td>BOM</td><td>DOM</td></tr></tbody></table><h3 id="在node环境中"><a href="#在node环境中" class="headerlink" title="在node环境中"></a>在node环境中</h3><table><thead><tr><th>node中的JavaScript</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td>ECMAScript</td><td>NPM</td><td>NATIVE</td></tr></tbody></table><h3 id="在小程序中"><a href="#在小程序中" class="headerlink" title="在小程序中"></a>在小程序中</h3><table><thead><tr><th>小程序中的JavaScript</th><th>&nbsp;</th><th>&nbsp;</th></tr></thead><tbody><tr><td>ECMAScript</td><td>小程序的View</td><td>小程序的API</td></tr></tbody></table><h2 id="小提示"><a href="#小提示" class="headerlink" title="小提示"></a>小提示</h2><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;由于小程序能够运行的环境较多，有IOS、安卓、小程序开发工具，在同一个平台上也会有不同的系统版本，这会导致部分ES6的代码不能够在机型上完美兼容，这个时候，只要在IDE中开启，ES6转ES5即可！</p>]]></content>
      
      
      
        <tags>
            
            <tag> 微信小程序 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
